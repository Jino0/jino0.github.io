[{"categories":["Data"],"content":" 1 最小栈【LeetCode 直通车】：155 最小栈（简单） 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 实现 MinStack 类: MinStack() 初始化堆栈对象。 void push(int val) 将元素val推入堆栈。 void pop() 删除堆栈顶部的元素。 int top() 获取堆栈顶部的元素。 int getMin() 获取堆栈中的最小元素。 示例 1: 输入： [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --\u003e 返回 -3. minStack.pop(); minStack.top(); --\u003e 返回 0. minStack.getMin(); --\u003e 返回 -2. /** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.getMin() */ /** * initialize your data structure here. */ var MinStack = function () { this.stack = []; // 记录栈中所有元素 this.minArr = []; // 记录当前数目下的最小值 this.min = Number.MAX_SAFE_INTEGER; // 栈的最小值 this.count = 0; // 栈中的元素个数 }; /** * @param {number} val * @return {void} */ MinStack.prototype.push = function (val) { this.min = Math.min(val, this.min); this.minArr[this.count] = this.min; this.stack[this.count] = val; this.count++; }; /** * @return {void} */ MinStack.prototype.pop = function () { const element = this.stack[this.count - 1]; if (this.count - 2 \u003e= 0) this.min = this.minArr[this.count - 2]; else this.min = Number.MAX_SAFE_INTEGER; delete this.minArr[this.count - 1]; delete this.stack[this.count - 1]; this.count--; return element; }; /** * @return {number} */ MinStack.prototype.top = function () { if (this.count \u003e= 1) return this.stack[this.count - 1]; else return null; }; /** * @return {number} */ MinStack.prototype.getMin = function () { return this.minArr[this.count - 1]; }; ","date":"2022-09-05","objectID":"/stack/:1:0","series":[],"tags":["stack"],"title":"栈 相关","uri":"/stack/#最小栈"},{"categories":["Data"],"content":" 2 下一个更大元素 I【LeetCode 直通车】：496 下一个更大元素 I（简单) nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置右侧的第一个比 x 大的元素。 给你两个没有重复元素的数组 nums1 和 nums2 ，下标从 0 开始计数，其中 nums1 是 nums2 的子集。 对于每个 0 \u003c= i \u003c nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的下一个更大元素 。 如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的下一个更大元素 。 示例 1： 输入：nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出：[-1,3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。 - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 示例 2： 输入：nums1 = [2,4], nums2 = [1,2,3,4]. 输出：[3,-1] 解释：nums1 中每个值的下一个更大元素如下所述： - 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。 - 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 /** * @param {number[]} nums * @return {number[]} */ // 4 1 2 // 2 5 3 6 8 4 7 1 // 7 // stack: 2 5 6 8 // map: -1 -1 7 // 7 -1 5 var nextGreaterElement = function(nums1, nums2) { const map = new Map(); const stack = []; for (let i = nums2.length - 1; i \u003e= 0; --i) { const num = nums2[i]; while (stack.length \u0026\u0026 num \u003e= stack[stack.length - 1]) { stack.pop(); } map.set(num, stack.length ? stack[stack.length - 1] : -1); stack.push(num); } const res = new Array(nums1.length).fill(0).map((_, i) =\u003e map.get(nums1[i])); return res; }； ","date":"2022-09-05","objectID":"/stack/:2:0","series":[],"tags":["stack"],"title":"栈 相关","uri":"/stack/#下一个更大元素-i"},{"categories":["Data"],"content":" 3 下一个更大元素 II【LeetCode 直通车】：503 下一个更大元素 II（中等） 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。 示例 1: 输入: nums = [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 示例 2: 输入: nums = [1,2,3,4,3] 输出: [2,3,4,-1,4] ","date":"2022-09-05","objectID":"/stack/:3:0","series":[],"tags":["stack"],"title":"栈 相关","uri":"/stack/#下一个更大元素-ii"},{"categories":["Data"],"content":" 4 有效的括号【LeetCode 直通车】：20 有效的括号（中等） 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1： 输入：s = \"()\" 输出：true 示例 2： 输入：s = \"()[]{}\" 输出：true 示例 3： 输入：s = \"(]\" 输出：false /** * @param {string} s * @return {boolean} */ var isValid = function(s) { if (s.length === 0) { return true; } if (s.length % 2 !== 0) { return false; } let map = { ')': '(', ']': '[', '}': '{', }; let left = ['(', '[', '{']; let right = [')', ']', '}']; let stack = new Stack(); for (let i = 0; i \u003c s.length; i++) { if (!right.includes(s[i])) { stack.push(s[i]); } else { const matchStr = map[s[i]]; while (!stack.isEmpty()) { const element = stack.pop(); if (left.includes(element) \u0026\u0026 matchStr !== element) return false; if (element === matchStr) break; } } } return stack.isEmpty(); }; class Stack { constructor() { this.count = 0; this.items = []; } push(element) { this.items[this.count] = element; this.count++; } pop() { if (this.isEmpty()) return undefined; const element = this.items[this.count - 1]; delete this.items[this.count - 1]; this.count--; return element; } isEmpty() { return this.size() === 0; } size() { return this.count; } } ","date":"2022-09-05","objectID":"/stack/:4:0","series":[],"tags":["stack"],"title":"栈 相关","uri":"/stack/#有效的括号"},{"categories":["Data"],"content":" 5 简化路径【LeetCode 直通车】：71 简化路径（中等） 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）； 两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。 请注意，返回的规范路径 必须遵循下述格式： 始终以斜杠 '/' 开头。 两个目录名之间必须只有一个斜杠 '/' 。 最后一个目录名（如果存在）不能 以 '/' 结尾。 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。 返回简化后得到的 规范路径 。 示例 1： 输入：path = \"/home/\" 输出：\"/home\" 解释：注意，最后一个目录名后面没有斜杠。 示例 2： 输入：path = \"/../\" 输出：\"/\" 解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。 示例 3： 输入：path = \"/home//foo/\" 输出：\"/home/foo\" 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4： 输入：path = \"/a/./b/../../c/\" 输出：\"/c\" /** * @param {string} path * @return {string} */ var simplifyPath = function(path) { let newPath = path.split('/'); newPath = newPath.filter(item =\u003e item !== \"\"); const stack = new Stack(); for (let s of newPath) { if (s === '..') stack.pop(); else if (s !== '.') stack.push(s); } if (stack.isEmpty()) return '/'; let str = ''; while (!stack.isEmpty()) { const element = stack.pop(); str = '/' + element + str; } return str; }; class Stack { constructor() { this.count = 0; this.items = []; } push(element) { this.items[this.count] = element; this.count++; } pop() { if (this.isEmpty()) return undefined; const element = this.items[this.count - 1]; delete this.items[this.count - 1]; this.count--; return element; } size() { return this.count; } isEmpty() { return this.size() === 0; } } ","date":"2022-09-05","objectID":"/stack/:5:0","series":[],"tags":["stack"],"title":"栈 相关","uri":"/stack/#简化路径"},{"categories":["algorithm"],"content":"回溯法可以理解为通过选择不同的岔路口寻找目的地，一个岔路口一个岔路口的去尝试找到目的地。如果走错了路，继续返回来找到岔路口的另一条路，直到找到目的地。 ","date":"2022-09-05","objectID":"/backtracking/:0:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#"},{"categories":["algorithm"],"content":" 1 简介一种能避免不必要搜索的穷举式的搜索算法。采用试错的思想，在搜索尝试过程中寻找问题的解，当探索到某一步时，发现原先的选择并不满足求解条件，或者还需要满足更多求解条件时，就退回一步（回溯）重新选择，这种走不通就退回再走的技术称为「回溯法」，而满足回溯条件的某个状态的点称为「回溯点」。 简单来说，回溯算法采用了一种 「走不通就回退」 的算法思想。 回溯算法通常用简单的递归方法来实现，在进行回溯过程中更可能会出现两种情况： 找到一个可能存在的正确答案； 在尝试了所有可能的分布方法之后宣布该问题没有答案。 回溯算法的基本思想是：以深度优先搜索的方式，根据产生子节点的条件约束，搜索问题的解。当发现当前节点已不满足求解条件时，就「回溯」返回，尝试其他的路径。 那么，在写回溯算法时，我们可以按照这个思想来书写回溯算法，具体步骤如下： 明确所有选择：画出搜索过程的决策树，根据决策树来确定搜索路径。 明确终止条件：推敲出递归的终止条件，以及递归终止时的要执行的处理方法。 将决策树和终止条件翻译成代码： 定义回溯函数（明确函数意义、传入参数、返回结果等）。 书写回溯函数主体（给出约束条件、选择元素、递归搜索、撤销选择部分）。 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。 ","date":"2022-09-05","objectID":"/backtracking/:1:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#简介"},{"categories":["algorithm"],"content":" 2 通用模版 res = [] # 存放所欲符合条件结果的集合 path = [] # 存放当前符合条件的结果 def backtracking(nums): # nums 为选择元素列表 if 遇到边界条件: # 说明找到了一组符合条件的结果 res.append(path[:]) # 将当前符合条件的结果放入集合中 return for i in range(len(nums)): # 枚举可选元素列表 # 有时该处也应该加入一遍筛选条件，具体看题 path.append(nums[i]) # 选择元素 backtracking(nums) # 递归搜索 path.pop() # 撤销选择 backtracking(nums) ","date":"2022-09-05","objectID":"/backtracking/:2:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#通用模版"},{"categories":["algorithm"],"content":" 3 子集【LeetCode 直通车】：78 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 输入：nums = [0] 输出：[[],[0]] /** * @param {number[]} nums * @return {number[][]} */ var subsets = function(nums) { let res = []; backTrack(nums, res, 0, []); return res; }; function backTrack(nums, res, index, track){ if(Array.isArray(track)){ res.push(track.slice()); } if(index === nums.length){ return ; } for(let i=index; i\u003cnums.length; i++){ track.push(nums[i]); backTrack(nums, res, i+1, track);// [] track.pop(); } } [] [1] [1,2] [1,2,3] [1,3] [2] [2,3] [3] i=0 [1] index=1 [1] i=1 index=2 [1,2] i=2 index=3 [1,2,3] b; pop [1,2] i=1 index=2 [1,2] pop [1] i=2 index=3 [1,3] pop [1] i=0 [1] index=1 [1] pop [] i=1 index=2 [2] i=2 index=3 [2,3] pop [2] i=2 var subsets = function(nums) { const t = []; const ans = []; const dfs = (cur) =\u003e { if (cur === nums.length) { ans.push(t.slice()); return; } t.push(nums[cur]); // [1] [1,2] [1,2,3] dfs(cur + 1); t.pop(t.length - 1); dfs(cur + 1); } dfs(0); return ans; }; ","date":"2022-09-05","objectID":"/backtracking/:3:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#子集"},{"categories":["algorithm"],"content":" 4 全排列【LeetCode 直通车】：46 全排列（中等） 给定一个不含重复数字的数组 nums ，返回其所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3： 输入：nums = [1] 输出：[[1]] /** * @param {number[]} nums * @return {number[][]} */ let results = []; var permute = function(nums) { results = []; backtrack(nums, []); return results; }; function backtrack(nums, track) { if (nums.length === track.length) { results.push(track.slice()); return; } for (let i = 0; i \u003c nums.length; i++) { if (track.includes(nums[i])) continue; track.push(nums[i]); backtrack(nums, track); track.pop(); } } ","date":"2022-09-05","objectID":"/backtracking/:4:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#全排列"},{"categories":["algorithm"],"content":" 5 括号生成【LeetCode 直通车】：22 括号生成（中等） 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] 示例 2： 输入：n = 1 输出：[\"()\"] /** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { let validRes = []; backtrack(n * 2, validRes, ''); return validRes; }; function backtrack(len, validRes, bracket) { if (bracket.length === len) { if (isValidCombination(bracket)) { validRes.push(bracket); } return; } for (let str of ['(', ')']) { bracket += str; backtrack(len, validRes, bracket); bracket = bracket.slice(0, bracket.length - 1); } } function isValidCombination(bracket) { // (())() let stack = new Stack(); for (let i = 0; i \u003c bracket.length; i++) { const str = bracket[i]; if (str === '(') { stack.push(str); } else if (str === ')') { const top = stack.pop(); if (top !== '(') return false; } } return stack.isEmpty(); } class Stack { constructor() { this.count = 0; this.items = []; } push(element) { this.items[this.count] = element; this.count++; } pop() { if (this.isEmpty()) return; const element = this.items[this.count - 1]; delete this.items[this.count - 1]; this.count--; return element; } size() { return this.count; } isEmpty() { return this.size() === 0; } } ","date":"2022-09-05","objectID":"/backtracking/:5:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#括号生成"},{"categories":["algorithm"],"content":" 6 复原 IP 地址【LeetCode 直通车】：93 复原 IP 地址（中等） 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。 例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是有效 IP 地址，但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。 你不能重新排序或删除 s 中的任何数字。你可以按任何顺序返回答案。 示例 1： 输入：s = \"25525511135\" 输出：[\"255.255.11.135\",\"255.255.111.35\"] 示例 2： 输入：s = \"0000\" 输出：[\"0.0.0.0\"] 示例 3： 输入：s = \"101023\" 输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] /** * @param {string} s * @return {string[]} */ var restoreIpAddresses = function (s) { if (s.length \u003e 12) return []; let res = []; const track = []; backtracking(s, res, track); return res; }; function backtracking(s, res, track) { if (track.length === 4 \u0026\u0026 s.length === 0) { res.push(track.join('.')); return; } const len = s.length \u003e= 3 ? 3 : s.length; for (let i = 0; i \u003c len; i++) { const str = s.slice(0, i + 1); if (parseInt(str) \u003e 255) continue; if (i \u003e= 1 \u0026\u0026 parseInt(str) \u003c (1 + '0'.repeat(i))) continue; track.push(str); backtracking(s.slice(i + 1), res, track); track.pop(); } } //2 var restoreIpAddresses = function(s) { const SEG_COUNT = 4; const segments = new Array(SEG_COUNT); const ans = []; const dfs = (s, segId, segStart) =\u003e { // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案 if (segId === SEG_COUNT) { if (segStart === s.length) { ans.push(segments.join('.')); } return; } // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯 if (segStart === s.length) { return; } // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0 if (s.charAt(segStart) === '0') { segments[segId] = 0; dfs(s, segId + 1, segStart + 1); } // 一般情况，枚举每一种可能性并递归 let addr = 0; for (let segEnd = segStart; segEnd \u003c s.length; ++segEnd) { addr = addr * 10 + (s.charAt(segEnd) - '0'); if (addr \u003e 0 \u0026\u0026 addr \u003c= 0xFF) { segments[segId] = addr; dfs(s, segId + 1, segEnd + 1); } else { break; } } } dfs(s, 0, 0); return ans; }; ","date":"2022-09-05","objectID":"/backtracking/:6:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#复原-ip-地址"},{"categories":["algorithm"],"content":" 7 N皇后【LeetCode 直通车】：51 N皇后（困难） 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例： 输入 n = 4 输出 [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] 解释 如下图所示，4 皇后问题存在 2 个不同的解法。 /** * @param {number} n * @return {string[][]} */ var solveNQueens = function (n) { let res = [], board = []; for (let i = 0; i \u003c n; i++) { board[i] = []; for (j = 0; j \u003c n; j++) { board[i][j] = '.'; } } backtracking(0, res, board, n); return res; }; function backtracking(row, res, board, n) { if (row === n) { // 合理结果push,递归结束 res.push(deepClone(board)); return; } for (let i = 0; i \u003c n; i++) { if (checkIsNotValid(board, row, i, n)) continue;//检查解的合理性 board[row][i] = 'Q';// 写入解 backtracking(row + 1, res, board, n);//递归 board[row][i] = '.'; // 回溯 } } function checkIsNotValid(board, row, column, n) { // 行 for (let i = 0; i \u003c n; i++) { if (board[i][column] === 'Q') return true; } // 列 不必要，因为是一行行下来的所以没必要了 for (let i = 0; i \u003c n; i++) { if (board[row][i] === 'Q') return true; } // 斜线，又分为：右上，右下，左上，左下。也是因为一行行下来的，所以只需要检测上面的。左上，右上 // 左上 for (let i = row - 1, j = column - 1; i \u003e= 0 \u0026\u0026 j \u003e= 0; i--, j--) { if (board[i][j] === 'Q') return true; } // 右上 for (let i = row - 1, j = column + 1; i \u003e= 0 \u0026\u0026 j \u003c n; i--, j++) { if (board[i][j] === 'Q') return true; } } function deepClone(board) { let res = []; for (let i = 0; i \u003c board.length; i++) { res[i] = board[i].join(''); } return res; } ","date":"2022-09-05","objectID":"/backtracking/:7:0","series":[],"tags":["backtracking"],"title":"回溯 算法","uri":"/backtracking/#n皇后"},{"categories":["algorithm"],"content":" 深度优先遍历（Depth First Search, 简称 DFS） 与广度优先遍历（Breath First Search）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫），搜索引擎，爬虫等，也频繁出现在 leetcode，高频面试题中。 ","date":"2022-09-01","objectID":"/bfs-dfs/:0:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#"},{"categories":["algorithm"],"content":" 1 DFS 简介先递归下去，再回溯上来。从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。 ","date":"2022-09-01","objectID":"/bfs-dfs/:1:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#dfs-简介"},{"categories":["algorithm"],"content":" 2 BFS 简介从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。 深度优先搜索旨在不管有多少条岔路，先一条路走到底，不成功就返回上一个路口然后就选择下一条岔路，而广度优先搜索旨在面临一个路口时，把所有的岔路口都记下来，然后选择其中一个进入，然后将它的分路情况记录下来，然后再返回来进入另外一个岔路，并重复这样的操作。 ","date":"2022-09-01","objectID":"/bfs-dfs/:2:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#bfs-简介"},{"categories":["algorithm"],"content":" 3 数据结构上的运用DFS 用递归的形式，用到了栈结构，先进后出。 BFS 选取状态用队列的形式，先进先出。 ","date":"2022-09-01","objectID":"/bfs-dfs/:3:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#数据结构上的运用"},{"categories":["algorithm"],"content":" 4 复杂度DFS 的复杂度与BFS的复杂度大体一致，不同之处在于遍历的方式与对于问题的解决出发点不同，DFS适合目标明确，而BFS适合大范围的寻找。 ","date":"2022-09-01","objectID":"/bfs-dfs/:4:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#复杂度"},{"categories":["algorithm"],"content":" 5 思想思想上来说这两种方法都是穷竭列举所有的情况。 ","date":"2022-09-01","objectID":"/bfs-dfs/:5:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#思想"},{"categories":["algorithm"],"content":" 5.1 高频算法题系列：BFS","date":"2022-09-01","objectID":"/bfs-dfs/:5:1","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#高频算法题系列bfs"},{"categories":["algorithm"],"content":" 6 打开转盘锁 BFS【LeetCode 直通车】：752 打开转盘锁（中等 有一把带有四个数字的密码锁，每个位置上有 0 ~ 9 共 10 个数字。每次只能将其中一个位置上的数字转动一下。可以向上转，也可以向下转。 比如：1 -\u003e 2、2 -\u003e 1。 密码锁的初始数字为：0000。现在给定一组表示死亡数字的字符串数组 deadends，和一个带有四位数字的目标字符串 target。 如果密码锁转动到 deadends 中任一字符串状态，则锁就会永久锁定，无法再次旋转。 要求：给出最小的选择次数，使得锁的状态由 0000 转动到 target。 /** * @param {string[]} deadends * @param {string} target * @return {number} */ var openLock = function(deadends, target) { let queue = new Queue(); let visited = new Set(); let step = 0; queue.push('0000'); visited.add('0000'); while (!queue.isEmpty()) { let size = queue.size(); for (let i = 0; i \u003c size; i++) { let str = queue.pop(); if (deadends.includes(str)) continue; if (target === str) { return step; } for (let j = 0; j \u003c 4; j++) { let plusStr = plusOne(str, j); let minusStr = minusOne(str, j); if (!visited.has(plusStr)) { queue.push(plusStr); visited.add(plusStr) } if (!visited.has(minusStr)) { queue.push(minusStr); visited.add(minusStr) } } } step++; } return -1; }; function plusOne(str, index) { let strArr = str.split(''); if (strArr[index] === '9') { strArr[index] = '0' } else { strArr[index] = (Number(strArr[index]) + 1).toString() } return strArr.join(''); } function minusOne(str, index) { let strArr = str.split(''); if (strArr[index] === '0') { strArr[index] = '9' } else { strArr[index] = (Number(strArr[index]) - 1).toString() } return strArr.join(''); } class Queue { constructor() { this.items = []; this.count = 0; this.lowerCount = 0; } push(elem) { this.items[this.count++] = elem; } pop() { if (this.isEmpty()) { return; } const elem = this.items[this.lowerCount]; delete this.items[this.lowerCount]; this.lowerCount++; return elem; } isEmpty() { if (this.size() === 0) return true; return false; } size() { return this.count - this.lowerCount; } } ","date":"2022-09-01","objectID":"/bfs-dfs/:6:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#打开转盘锁-bfs"},{"categories":["algorithm"],"content":" 7 二叉树的最小深度 BFS【LeetCode 直通车】：111 二叉树的最小深度（简单） 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } * * @param {TreeNode} root * @return {number} */ var minDepth = function(root) { if (root == null) return 0; let depth = 1; let queue = new Queue(); queue.push(root); while (!queue.isEmpty()) { let size = queue.size(); for (let i = 0; i \u003c size; i++) { const node = queue.pop(); if (node.left == null \u0026\u0026 node.right == null) return depth; if (node.left) { queue.push(node.left); } if (node.right) { queue.push(node.right); } } depth++; } return depth; }; class Queue { constructor() { this.items = []; this.count = 0; this.lowerCount = 0; } push(elem) { this.items[this.count++] = elem; } pop() { if (this.isEmpty()) { return; } const elem = this.items[this.lowerCount]; delete this.items[this.lowerCount]; this.lowerCount++; return elem; } isEmpty() { if (this.size() === 0) return true; return false; } size() { return this.count - this.lowerCount; } } ","date":"2022-09-01","objectID":"/bfs-dfs/:7:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#二叉树的最小深度-bfs"},{"categories":["algorithm"],"content":" 8 岛屿的最大面积 DFS【LeetCode 直通车】：695 岛屿的最大面积（中等） 描述：给定一个只包含 0、1 元素的二维数组，1 代表岛屿，0 代表水。一座岛的面积就是上下左右相邻的 1 所组成的连通块的数目。 要求：计算出最大的岛屿面积。 /** * @param {number[][]} grid * @return {number} */ let maxX, maxY; let visited; let globalMaxArea; var maxAreaOfIsland = function(grid) { visited = new Set(); maxX = grid.length; maxY = grid[0].length; globalMaxArea = 0; for (let i = 0; i \u003c maxX; i++) { for (let j = 0; j \u003c maxY; j++) { if (grid[i][j] === 1) { visited.add(`(${i}, ${j})`); globalMaxArea = Math.max(globalMaxArea, dfs(grid, i, j)); } visited.clear(); } } return globalMaxArea; }; function dfs(grid, x, y) { let res = 1; for (let i = -1; i \u003c= 1; i++) { for (let j = -1; j \u003c= 1; j++) { if (Math.abs(i) === Math.abs(j)) continue; const newX = x + i; const newY = y + j; if (newX \u003e= maxX || newX \u003c 0 || newY \u003e= maxY || newY \u003c 0) continue; if (visited.has(`(${newX}, ${newY})`)) continue; visited.add(`(${newX}, ${newY})`); const areaCnt = grid[newX][newY] if (areaCnt === 1) { const cnt = dfs(grid, newX, newY); res += cnt; } } } return res; } ","date":"2022-09-01","objectID":"/bfs-dfs/:8:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#岛屿的最大面积-dfs"},{"categories":["algorithm"],"content":" 9 相同的树 DFS【LeetCode 直通车】：100 相同的树（简单） 给定两个二叉树 p 和 q。判断这两棵树是否相同。 两棵树相同的定义： 结构上相同； 节点具有相同的值 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } * * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */ var isSameTree = function(p, q) { if (p == null \u0026\u0026 q == null) return true; if (p == null || q == null) return false; if (p.val !== q.val) return false; return isSameTree(p.left, q.left) \u0026\u0026 isSameTree(p.right, q.right); }; ","date":"2022-09-01","objectID":"/bfs-dfs/:9:0","series":[],"tags":["BFS","DFS"],"title":"DFS \u0026\u0026 BFS ","uri":"/bfs-dfs/#相同的树-dfs"},{"categories":["algorithm"],"content":"常见的排序算法相关题。 ","date":"2022-08-31","objectID":"/sort-2/:0:0","series":[],"tags":["Sort"],"title":"排序算法题","uri":"/sort-2/#"},{"categories":["algorithm"],"content":" 1 用最少数量的箭引爆气球 【LeetCode 451】最少数量的箭（中等） 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 `xstart ≤ x ≤ xend`，则该气球会被引爆。可以射出的弓箭的数量没有限制。弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小弓箭数 。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：气球可以用 2 支箭来爆破: - 在 x = 6 处射出箭，击破气球 [2,8] 和 [1,6]。 - 在 x = 11 处发射箭，击破气球 [10,16] 和 [7,12]。 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 解释：每个气球需要射出一支箭，总共需要 4 支箭。 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 解释：气球可以用2支箭来爆破: - 在 x = 2 处发射箭，击破气球 [1,2] 和 [2,3]。 - 在 x = 4 处射出箭，击破气球 [3,4] 和 [4,5]。 其实就是找可以重叠的，跟嵌套还不一样，只要有重叠部分就可以用一支剑来打破。 先给 [start, end] 中的 end 排序，得到 end 为递增的数组。 再判断 start ，当后一个 start2 大于上一个 end1 的时候，就需要再射出一支箭。 当上一个 end1 大于 后一个 start2 的时候，即有 end1 \u003e start2 ，本身 start1 \u003c end1，start2 \u003c end2 。 故有 start1 \u003c start2 \u003c end2 \u003c start2，即有重叠部分，只用一支箭即可。 [1,6][2,8][7,12][10,16] 0123456 0023456 78 0000007 89123 0000000 001234567 /** * @param {number[][]} points * @return {number} */ var findMinArrowShots = function(points) { if (!points.length ) { return 0; } points.sort((a, b) =\u003e a[1] - b[1]); let pos = points[0][1] let ans = 1; for (let balloon of points) { if (balloon[0] \u003e pos) { pos = balloon[1]; ans++; } } return ans; }* ","date":"2022-08-31","objectID":"/sort-2/:1:0","series":[],"tags":["Sort"],"title":"排序算法题","uri":"/sort-2/#用最少数量的箭引爆气球"},{"categories":["algorithm"],"content":" 2 合并区间 【LeetCode 56】 合并区间（中等） 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。 请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 先对 [starti, endi] 中的 starti 排序。 整一个新数组，只包含第一个元素，然后遍历后面的依次拿到，逐步插入。 插入的时候，比较 未排序的第一个 start 与 已排序的最后一个 end。 如果小于，说明重叠，更新已排序的end，如果大于，说明没有重叠，直接添加进来即可。 intervals = [[1,3],[2,6],[8,10],[15,18]] /** * @param {number[][]} intervals * @return {number[][]} */ var merge = function(intervals) { if (intervals.length === 0) return []; intervals.sort((a, b) =\u003e a[0] - b[0]); let mergeArr = [intervals[0]]; let last, curr; for (let j = 1; j \u003c intervals.length; j++) { last = mergeArr[mergeArr.length - 1]; // last[1] : 已合并的最右(最大) curr = intervals[j]; // curr[0] : 待合并的最左(最小) if (last[1] \u003e= curr[0]) { last[1] = Math.max(curr[1], last[1]); } else { mergeArr.push(curr); } } return mergeArr; }; ","date":"2022-08-31","objectID":"/sort-2/:2:0","series":[],"tags":["Sort"],"title":"排序算法题","uri":"/sort-2/#合并区间"},{"categories":["algorithm"],"content":"常见的排序算法 各种性能总结 方法 平均时间复杂度 最佳时间复杂度 最差时间复杂度 空间复杂度 排序方式 稳定性 冒泡排序 O(N^2) O(N) O(N^2) O(1) In-place YES 插入排序 选择排序 计数排序 O(n + k) O(n + k) O(n + k) O(n + k) 希尔排序 O(Nlog2N) O(N^2) O(1) NO 快速排序 O(NlogN) O(NlogN) O(N^2) 堆排序 桶排序 O(n + k) O(n + k) O(n ^ 2) O(n * k) 稳定 基数排序 ","date":"2022-08-30","objectID":"/sort/:0:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#"},{"categories":["algorithm"],"content":" 1 冒泡排序注意三个 优化点 let arr = [3, 5, 1, 7, 0, 2, 4, 6]; var bubbleSort = function (arr) { let flag = 0; for (let i = 0; i \u003c arr.length-1; i++) { //优化1: j \u003c legnth-i-1; 内部循环不用遍历 nlen-1;因为每一次 i+1均表示已经有一个在了合适的位置上 for (let j = 0; j \u003c arr.length - 1 - i; j++) { if (arr[j] \u003e arr[j + 1]) { let temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; } //优化3:记录此刻的值，j+1往后的数组已经为有序数组 flag = j+1; } //优化2: 如果值没变,说明该数组已经是有序的数组了，排序结束 if (flag == 0) { break; } if (flag) { i = arr.length - flag -1; } } return arr; } console.log(bubbleSort(arr)); ","date":"2022-08-30","objectID":"/sort/:1:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#冒泡排序"},{"categories":["algorithm"],"content":" 1.1 双向冒泡排序 let arr = [3, 5, 1, 7, 0, 2, 4, 6]; var bubbleSortDouble = function (arr) { if (arr.length \u003c 0) return; let low = 0, high = arr.length - 1; while (low \u003c high) { // 大的从左往右走，走到最右边 for (let i = low; i \u003c high; i++) { if (arr[i] \u003e arr[i + 1]) { let temp = arr[i + 1]; arr[i + 1] = arr[i]; arr[i] = temp; } } high--; // 小的从右向左走，走到最左边 for (let j = high; j \u003e low; j--) { if (arr[j] \u003c arr[j - 1]) { let temp = arr[j - 1]; arr[j - 1] = arr[j]; arr[j] = temp; } } low++; } return arr; } console.log(bubbleSortDouble(arr)); ","date":"2022-08-30","objectID":"/sort/:1:1","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#双向冒泡排序"},{"categories":["algorithm"],"content":" 2 选择排序 let arr = [3, 5, 1, 7, 0, 2, 4, 6]; var SelectSort = function (arr) { if (arr.length \u003c 0) return; let nMin = 0; for (let i = 0; i \u003c arr.length - 1; i++) { nMin = i; for (let j = i; j \u003c arr.length; j++) { if (arr[nMin] \u003e arr[j]) { arr[nMin] = arr[nMin] ^ arr[j]; arr[j] = arr[nMin] ^ arr[j]; arr[nMin] = arr[nMin] ^ arr[j]; } } // nMin = i; // for (let j = i; j \u003c arr.length; j++) // { // if (arr[j] \u003c arr[nMin]) // { // nMin = j; // } // } // //prletf(\"最小值为:%d,对应索引为：%d\\n\", arr[nMin], nMin); // if (i != nMin) // { // swap(\u0026arr[nMin], \u0026arr[i]); // } } return arr; } console.log(SelectSort(arr)); ","date":"2022-08-30","objectID":"/sort/:2:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#选择排序"},{"categories":["algorithm"],"content":" 3 插入排序 //-------插入排序------------------------------------------- //从左向右的遍历过程中，在左侧构建有序序列，右侧元素依次插入左侧有序列表中 //有序、无序两个遍历 //插入的过程，即记录要插入点，找合适位置，往后挪动的过程 let arr = [3, 5, 1, 7, 0, 2, 4, 6]; var InsertSort = function (arr) { if (arr.length \u003c 0) return; let i, j, temp; //无序第一个 for (i = 0; i \u003c arr.length; i++) { j = i - 1; //有序最后一个 temp = arr[i]; //记录无序第一个 while (j \u003e= 0 \u0026\u0026 arr[j] \u003e temp) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = temp; } return arr; } console.log(InsertSort(arr)); ","date":"2022-08-30","objectID":"/sort/:3:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#插入排序"},{"categories":["algorithm"],"content":" 4 计数排序 ① 找出待排序的数组中最大和最小的元素 ② 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 ③ 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） ④ 反向填充目标数组：将每个元素i放在新数组的第C(i) 项，每放一个元素就将C(i) 减去1 let arr = [3, 5, 1, 7, 0, 2, 4, 6,2]; var CountSort = function (arr) { if (arr.length \u003c 0) return; let nMin = 0, nMax = 0; for (let i = 0; i \u003c arr.length; i++) { if (arr[i] \u003c nMin) { nMin = arr[i]; } if (arr[i] \u003e nMax) { nMax = arr[i]; } } let nMaxMin = nMax - nMin + 1; let pMark = new Array(nMaxMin).fill(0); for (let i = 0; i \u003c arr.length; i++) { pMark[arr[i] - nMin]++; } let j = 0; for (let i = 0; i \u003c nMaxMin; i++) { while (pMark[i] \u003e 0) { arr[j] = i + nMin; j = j + 1; pMark[i]--; } } return arr; } console.log(CountSort(arr)); ","date":"2022-08-30","objectID":"/sort/:4:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#计数排序"},{"categories":["algorithm"],"content":" 5 希尔排序 //-------希尔排序------------------------------------------- //分组插入，依然为有序最后一个，无序第一个 // 希尔排序的效率取决于增量值gap的选取，时间复杂度并不是一个定值。 let arr = [3, 5, 1, 7, 0, 2, 4, 6, 2]; // let arr = [12, 4, 10, 4, 2, 9, 7]; // let arr = [900,200,300,401,602,801]; var ShellSort = function (arr) { if (arr.length \u003c 0) return; let i, j, k, temp, gap = arr.length / 2; // 分组 for (gap = Math.floor(arr.length / 2); gap \u003e= 1; gap = Math.floor(gap/ 2)) { console.log(gap) // 各组依次遍历 for (i = 0; i \u003c gap; i++) { // 组内实行插入排序 for (k = i + gap; k \u003c arr.length; k += gap) { j = k - gap; temp = arr[k]; while (j \u003e= i \u0026\u0026 arr[j] \u003e temp) { arr[j + gap] = arr[j]; j -= gap; } arr[j + gap] = temp; } } } return arr; } console.log(ShellSort(arr)); ","date":"2022-08-30","objectID":"/sort/:5:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#希尔排序"},{"categories":["algorithm"],"content":" 6 快速排序","date":"2022-08-30","objectID":"/sort/:6:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#快速排序"},{"categories":["algorithm"],"content":" 6.1 区间分割 // 区间分割 int Sort1(int arr[], int nLow, int nHigh) { int nSmall; nSmall = nLow - 1; for (nLow = nLow; nLow \u003c nHigh; nLow++) { if (arr[nLow] \u003c arr[nHigh]) { if (++nSmall != nLow) { arr[nSmall] = arr[nSmall] ^ arr[nLow]; arr[nLow] = arr[nSmall] ^ arr[nLow]; arr[nSmall] = arr[nSmall] ^ arr[nLow]; } } } if (++nSmall != nHigh) { arr[nSmall] = arr[nSmall] ^ arr[nHigh]; arr[nHigh] = arr[nSmall] ^ arr[nHigh]; arr[nSmall] = arr[nSmall] ^ arr[nHigh]; } return nSmall; } void QuickSort(int arr[], int nLow, int nHigh) { if (arr == NULL || nLow \u003e= nHigh) return; int nStandard = Sort1(arr, nLow, nHigh); QuickSort(arr, nLow, nStandard - 1); QuickSort(arr, nStandard + 1, nHigh); } ","date":"2022-08-30","objectID":"/sort/:6:1","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#区间分割"},{"categories":["algorithm"],"content":" 6.2 挖坑填补 // 挖坑填补 int Sort(int arr[], int nLow, int nHigh) { if (arr == NULL || nLow \u003e= nHigh) return 0; int temp = arr[nLow]; //以此值将数组分割为两部分 while (nLow \u003c nHigh) { //从后往前找小的 while (nLow \u003c nHigh) { if (arr[nHigh] \u003c temp) { arr[nLow] = arr[nHigh]; nLow++; break; } nHigh--; } //从前往后找大的 while (nLow \u003c nHigh) { if (arr[nLow] \u003e temp) { arr[nHigh] = arr[nLow]; nHigh--; break; } nLow++; } } arr[nLow] = temp; return nLow; } // void QuickSort(int arr[], int nLow, int nHigh) { if (arr == NULL || nLow \u003e= nHigh) return; int nStandard = Sort1(arr, nLow, nHigh); QuickSort(arr, nLow, nStandard - 1); QuickSort(arr, nStandard + 1, nHigh); } ","date":"2022-08-30","objectID":"/sort/:6:2","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#挖坑填补"},{"categories":["algorithm"],"content":" 7 归并排序 void Merge(int arr[], int nLow, int nHigh) { if (arr == NULL || nLow \u003e= nHigh) return; int nBegin1, nEnd1, nBegin2, nEnd2; nBegin1 = nLow; nEnd1 = nLow + (nHigh - nLow) / 2; nBegin2 = nEnd1 + 1; nEnd2 = nHigh; int *pTemp = (int *)malloc(sizeof(int) * (nHigh - nLow + 1)); int i = 0; while (nBegin1 \u003c= nEnd1 \u0026\u0026 nBegin2 \u003c= nEnd2) { if (arr[nBegin1] \u003c arr[nBegin2]) { pTemp[i] = arr[nBegin1]; nBegin1++; } else { pTemp[i] = arr[nBegin2]; nBegin2++; } i++; } while (nBegin1 \u003c= nEnd1) { pTemp[i] = arr[nBegin1]; i++; nBegin1++; } while (nBegin2 \u003c= nEnd2) { pTemp[i] = arr[nBegin2]; i++; nBegin2++; } for (int j = 0; j \u003c nHigh - nLow + 1; j++) { arr[nLow + j] = pTemp[j]; } } void MergeSort(int arr[], int nLow, int nHigh) { if (arr == NULL || nLow \u003e= nHigh) return; int nMid = nLow + (nHigh - nLow) / 2; MergeSort(arr, nLow, nMid); MergeSort(arr, nMid + 1, nHigh); Merge(arr, nLow, nHigh); } ","date":"2022-08-30","objectID":"/sort/:7:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#归并排序"},{"categories":["algorithm"],"content":" 8 堆排序 建堆的过程，只能保证最大的再最上面，可以保证所有的父节点均比子节点大，但是不能保证子节点之间的大小。 所以需要仅一步操作，每次均取最大值即可。 #define LEFT 2 * nRootid + 1 #define RIGHT 2 * nRootid + 2 void Adjust(int arr[], int nlen, int nRootid) { while (1) { if (RIGHT \u003c nlen) { if (arr[LEFT] \u003c arr[RIGHT]) { if (arr[RIGHT] \u003e arr[nRootid]) { arr[RIGHT] = arr[RIGHT] ^ arr[nRootid]; arr[nRootid] = arr[RIGHT] ^ arr[nRootid]; arr[RIGHT] = arr[RIGHT] ^ arr[nRootid]; nRootid = RIGHT; continue; } break; } else { if (arr[LEFT] \u003e arr[nRootid]) { arr[LEFT] = arr[LEFT] ^ arr[nRootid]; arr[nRootid] = arr[LEFT] ^ arr[nRootid]; arr[LEFT] = arr[LEFT] ^ arr[nRootid]; nRootid = LEFT; continue; } break; } } else if (LEFT \u003c nlen) { if (arr[LEFT] \u003e arr[nRootid]) { arr[LEFT] = arr[LEFT] ^ arr[nRootid]; arr[nRootid] = arr[LEFT] ^ arr[nRootid]; arr[LEFT] = arr[LEFT] ^ arr[nRootid]; nRootid = LEFT; } break; } else { break; } } } void HeapSort(int arr[], int nlen) { if (arr == NULL || nlen \u003c= 0) return; int i; for (i = nlen / 2 - 1; i \u003e= 0; i--) { Adjust(arr, nlen, i); } for (i = nlen - 1; i \u003e 0; i--) { arr[0] = arr[0] ^ arr[i]; arr[i] = arr[0] ^ arr[i]; arr[0] = arr[0] ^ arr[i]; Adjust(arr, i, 0); } } ","date":"2022-08-30","objectID":"/sort/:8:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#堆排序"},{"categories":["algorithm"],"content":" 9 桶排序 typedef struct node { int nValue; struct node *pNext; struct node *pPre; } Bucket; void Buckett(Bucket *pHead) { if (pHead == NULL || pHead-\u003epNext == NULL) return; Bucket *pSort = NULL; Bucket *pUnSort = NULL; pUnSort = pHead-\u003epNext; int temp; while (pUnSort != NULL) { pSort = pUnSort-\u003epPre; //4 temp = pUnSort-\u003enValue; //2 while (pSort != NULL \u0026\u0026 pSort-\u003enValue \u003e temp) { pSort-\u003epNext-\u003enValue = pSort-\u003enValue; pSort = pSort-\u003epPre; } if (pSort == NULL) { pHead-\u003enValue = temp; } else { pSort-\u003epNext-\u003enValue = temp; } pUnSort = pUnSort-\u003epNext; } } void BucketSort(int arr[], int nlen) { if (arr == NULL || nlen \u003c 0) return; int i, nMin, nMax, nMinIndex, nMaxIndex; nMin = arr[0]; nMax = arr[0]; for (i = 0; i \u003c nlen; i++) { if (arr[i] \u003c nMin) nMin = arr[i]; if (arr[i] \u003e nMax) nMax = arr[i]; } int nCount = 0; int nBase = 1; int nNum = nMin; while (nNum) { nCount++; nNum /= 10; } while (nCount) { nBase *= 10; nCount--; } nMinIndex = nMin / nBase; nMaxIndex = nMax / nBase; printf(\"nMInIndex: %d, nMaxIndex: %d\\n\", nMinIndex, nMaxIndex); Bucket **pBucket = (Bucket **)malloc(sizeof(Bucket) * (nMaxIndex - nMinIndex + 1)); memset(pBucket, 0, sizeof(Bucket) * (nMaxIndex - nMinIndex + 1)); Bucket *pTemp = NULL; for (i = 0; i \u003c nlen; i++) { nCount = arr[i] / nBase - nMinIndex; pTemp = (Bucket *)malloc(sizeof(Bucket)); pTemp-\u003enValue = arr[i]; pTemp-\u003epNext = pBucket[nCount]; if (pBucket[nCount] != NULL) { pBucket[nCount]-\u003epPre = pTemp; } pBucket[nCount] = pTemp; } for (i = 0; i \u003c nMaxIndex - nMinIndex + 1; i++) { Buckett(pBucket[i]); } nCount = 0; for (i = 0; i \u003c nMaxIndex - nMinIndex + 1; i++) { pTemp = pBucket[i]; while (pTemp) { arr[nCount] = pTemp-\u003enValue; nCount++; pTemp = pTemp-\u003epNext; } } Bucket *pDel = NULL; for (i = 0; i \u003c nMaxIndex - nMinIndex + 1; i++) { pTemp = pBucket[i]; while (pTemp) { pDel = pTemp; pTemp = pTemp-\u003epNext; free(pDel); pDel = NULL; } } free(pBucket); pBucket = NULL; } ","date":"2022-08-30","objectID":"/sort/:9:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#桶排序"},{"categories":["algorithm"],"content":" 10 基数排序 typedef struct Node { int nValue; struct Node *pNext; } Radix; void Radixx(int arr[], int nlen, int nNum, Radix **pRadix) { int nBase = 1; while (nNum \u003e 1) { nBase *= 10; nNum--; } int i; Radix *pTemp; Radix *pNode; for (i = 0; i \u003c nlen; i++) { nNum = arr[i] / nBase % 10; pTemp = (Radix *)malloc(sizeof(Radix)); pTemp-\u003enValue = arr[i]; pTemp-\u003epNext = NULL; if (pRadix[nNum] == NULL) { pRadix[nNum] = pTemp; } else { pNode = pRadix[nNum]; while (pNode-\u003epNext != NULL) { pNode = pNode-\u003epNext; } pNode-\u003epNext = pTemp; } } nNum = 0; for (i = 0; i \u003c 10; i++) { pTemp = pRadix[i]; while (pTemp) { arr[nNum] = pTemp-\u003enValue; pTemp = pTemp-\u003epNext; nNum++; } } for (i = 0; i \u003c 10; i++) { pTemp = pRadix[i]; while (pTemp) { pNode = pTemp; pTemp = pTemp-\u003epNext; free(pNode); pNode = NULL; } } memset(pRadix, 0, sizeof(Radix *) * 10); } void RadixSort(int arr[], int nlen) { if (arr == NULL || nlen \u003c= 0) return; int i, nMax; nMax = arr[0]; for (i = 0; i \u003c nlen; i++) { if (arr[i] \u003e nMax) { nMax = arr[i]; } } int nLoopTimes = 0; while (nMax) { nLoopTimes++; nMax /= 10; } Radix **pRadix = (Radix **)malloc(sizeof(Radix *) * 10); memset(pRadix, 0, sizeof(Radix *) * 10); for (i = 1; i \u003c= nLoopTimes; i++) { Radixx(arr, nlen, i, pRadix); } free(pRadix); pRadix = NULL; } ","date":"2022-08-30","objectID":"/sort/:10:0","series":[],"tags":["Sort"],"title":"十大经典排序","uri":"/sort/#基数排序"},{"categories":["Data"],"content":"高频算法题系列：二叉树 ","date":"2022-08-29","objectID":"/binarytree/:0:0","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#"},{"categories":["Data"],"content":" 1 二叉树的最近公共祖先 【LeetCode 236】 二叉树的最近公共祖先（简单） 例如，给定如上二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 如何找父指针 ？？？需要实现自底向下，怎么自底向上查找？？？ 后续遍历，回溯，即可实现。可通过后续遍历的过程中，利用 Map 存储节点的父节点（ key: 节点，value：父节点）。 然后获取 p 的父节点之后在此存储起来，在遍历 q 的父节点，找 p 刚存储的。 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @param {TreeNode} p * @param {TreeNode} q * @return {TreeNode} */ let visited; let parent; var lowestCommonAncestor = function(root, p, q) { visited = new Set(); parent = new Map(); dfs(root); while (p != null) { visited.add(p.val); p = parent.get(p.val); } while (q != null) { if (visited.has(q.val)) { return q; } q = parent.get(q.val); } return null; }; function dfs(root) { if (root.left != null) { parent.set(root.left.val, root); dfs(root.left); } if (root.right != null) { parent.set(root.right.val, root); dfs(root.right); } } ","date":"2022-08-29","objectID":"/binarytree/:1:0","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#二叉树的最近公共祖先"},{"categories":["Data"],"content":" 2 二叉搜索树中的搜索【LeetCode 700】 二叉搜索树中的搜索（简单） 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例 1: 输入： root = [4,2,7,1,3], val = 2 输出： [2,1,3] 示例 2: 输入： root = [4,2,7,1,3], val = 5 输出： [] /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } * * @param {TreeNode} root * @param {number} val * @return {TreeNode} */ var searchBST = function(root, val) { if (root == null) return null; if (root.val === val) return root; if (root.val \u003e val) { return searchBST(root.left, val); } else if (root.val \u003c val) { return searchBST(root.right, val); } }; ","date":"2022-08-29","objectID":"/binarytree/:2:0","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#二叉搜索树中的搜索"},{"categories":["Data"],"content":" 3 删除二叉搜索树中的节点【LeetCode 450】 删除二叉搜索树的节点（中等） 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 示例 1: 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2: 输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 示例 3: 输入: root = [], key = 0 输出: [] ","date":"2022-08-29","objectID":"/binarytree/:3:0","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#删除二叉搜索树中的节点"},{"categories":["Data"],"content":" 3.1 左的最右 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } * * @param {TreeNode} root * @param {number} key * @return {TreeNode} */ var deleteNode = function(root, key) { if (root == null) return null; if (root.val === key) { if (root.left == null \u0026\u0026 root.right == null) return null; if (root.left == null) return root.right; if (root.right == null) return root.left; if (root.left != null \u0026\u0026 root.right != null) {// 左的最右，或右的最左 let target = getMinTreeMaxNode(root.left); root.val = target.val; root.left = deleteNode(root.left, target.val); } } if (root.val \u003c key) { root.right = deleteNode(root.right, key); } else if (root.val \u003e key) { root.left = deleteNode(root.left, key); } return root; }; function getMinTreeMaxNode(root) { if (root.right == null) return root; return getMinTreeMaxNode(root.right); } ","date":"2022-08-29","objectID":"/binarytree/:3:1","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#左的最右"},{"categories":["Data"],"content":" 3.2 右的最左 var deleteNode = function(root, key) { if (root == null) return null; if (root.val === key) { if (root.left == null \u0026\u0026 root.right == null) return null; if (root.left == null) return root.right; if (root.right == null) return root.left; if (root.left != null \u0026\u0026 root.right != null) { let target = getMinTreeMaxNode(root.right); root.val = target.val; root.right = deleteNode(root.right, target.val); } } if (root.val \u003c key) { root.right = deleteNode(root.right, key); } else if (root.val \u003e key) { root.left = deleteNode(root.left, key); } return root; }; function getMinTreeMaxNode(root) { if (root.left == null) return root; return getMinTreeMaxNode(root.left); } ","date":"2022-08-29","objectID":"/binarytree/:3:2","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#右的最左"},{"categories":["Data"],"content":" 4 完全二叉树的节点个数【LeetCode 222】 完全二叉树的节点个数（中等） 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h 个节点。 示例 1： 输入：root = [1,2,3,4,5,6] 输出：6 示例 2： 输入：root = [] 输出：0 示例 3： 输入：root = [1] 输出：1 ß/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number} */ var countNodes = function(root) { if (root == null) return 0; let l = root, r = root; let lh = 0, rh = 0; while (l != null) { l = l.left; lh++; } while (r != null) { r = r.right; rh++; } if (lh === rh) { return Math.pow(2, lh) - 1; } return 1 + countNodes(root.left) + countNodes(root.right); }; ","date":"2022-08-29","objectID":"/binarytree/:4:0","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#完全二叉树的节点个数"},{"categories":["Data"],"content":" 5 二叉树的锯齿形层序遍历【LeetCode 103】锯齿形层序遍历（中等） 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[][]} */ let res; var zigzagLevelOrder = function(root) { if (root == null) return []; res = []; BFS(root, true); return res; }; function BFS(root, inOrder) { let resItem = []; let node; let stack1 = new Stack(); let stack2 = new Stack(); *// 判断交换时机* let flag; stack1.push(root); res.push([root.val]); inOrder = !inOrder; while (!stack1.isEmpty() || !stack2.isEmpty()) { if (stack1.isEmpty()) flag = 'stack1'; else if (stack2.isEmpty()) flag = 'stack2'; *// 决定取那个栈里面的元素* if (flag === 'stack2' \u0026\u0026 !stack1.isEmpty()) node = stack1.pop(); else if (flag === 'stack1' \u0026\u0026 !stack2.isEmpty()) node = stack2.pop(); if (inOrder) { if (node.left) { if (flag === 'stack1') stack1.push(node.left); else stack2.push(node.left) resItem.push(node.left.val); } if (node.right) { if (flag === 'stack1') stack1.push(node.right); else stack2.push(node.right); resItem.push(node.right.val); } } else { if (node.right) { if (flag === 'stack1') stack1.push(node.right); else stack2.push(node.right); resItem.push(node.right.val); } if (node.left) { if (flag === 'stack1') stack1.push(node.left); else stack2.push(node.left); resItem.push(node.left.val); } } *// 判断下次翻转的时机* if ((flag === 'stack2' \u0026\u0026 stack1.isEmpty()) || (flag === 'stack1' \u0026\u0026 stack2.isEmpty())) { inOrder = !inOrder; *// 需要翻转了，就加一轮值* if (resItem.length \u003e 0) res.push(resItem); resItem = []; } } } class Stack { constructor() { this.count = 0; this.items = []; } push(element) { this.items[this.count] = element; this.count++; } pop() { if (this.isEmpty()) return undefined; const element = this.items[this.count - 1]; delete this.items[this.count - 1]; this.count--; return element; } size() { return this.count; } isEmpty() { return this.size() === 0; } } ","date":"2022-08-29","objectID":"/binarytree/:5:0","series":[],"tags":["BinaryTree"],"title":"二叉树","uri":"/binarytree/#二叉树的锯齿形层序遍历"},{"categories":["algorithm"],"content":"动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。 This is a tip 本文致谢公众号 labuladong：动态规划详解（修订版） 既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。 但是动态规划的穷举有点特别，因为这类问题存在重叠子问题，如果暴力穷举的话效率会极其低下，所以需要备忘录或者DP table来优化穷举过程，避免不必要的计算。 而且，动态规划问题一定会具备最优子结构，才能通过子问题的最值得到原问题的最值。 另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的状态转移方程才能正确地穷举。 以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。 在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程： 明确 状态 -\u003e 定义 dp 数组/函数的含义 -\u003e 明确 选择-\u003e 明确 base case。 重点关注什么是重叠子问题（斐波那契数列严格来说不是动态规划问题）、如何列出状态转移方程。 计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。 列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。 备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门 ","date":"2022-08-25","objectID":"/dp/:0:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#"},{"categories":["algorithm"],"content":" 1 斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 //斐波那契数列 // 0 1 2 3 4 5 6 7 8 9 10 11 12 // 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 正常的普通递归，没有问题，思路也十分简单，但是重复计算量大，很容易把电脑干爆，数据量大的时候计算缓慢，缺点明显。 /** * @param {number} n * @return {number} */ var fib = function(n) { if(n\u003c2) return n; return fib(n-2)+fib(n-1); }; 优化的思路就是想办法，减少重复计算，想办法将之前的计算过程存储一下，引入 JS Map /** * @param {number} n * @return {number} */ // 0 1 2 3 4 5 6 7 8 9 10 11 12 // 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 var fib = function(n) { if (n \u003c 1) return 0; // 备忘录全初始化为 0 let memo = new Map(); // 初始化最简情况 return helper(memo, n); } var helper = function(memo, n) { // base case if (n == 1 || n == 2) return 1; // 已经计算过 if (memo.has(n)) return memo.get(n); memo.set(n, helper(memo, n - 1) + helper(memo, n - 2)); return memo.get(n)%1000000007; } 有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！ /** * @param {number} n * @return {number} */ var fib = function(n) { let dp=[]; // base case dp[0]=0; dp[1] = dp[2] = 1; for (let i = 3; i \u003c= n; i++) dp[i] = (dp[i - 1] + dp[i - 2])%1000000007; return dp[n]; }; 画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。 这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式： 为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。 你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。 千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。 这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)： var fib = function(n) { const MOD = 1000000007; if (n \u003c 2) { return n; } let i1 = 0, i2 = 0, i3 = 1; for (let i = 2; i \u003c= n; ++i) { i1 = i2; i2 = i3; i3 = (i1 + i2) % MOD; } return r; }; ","date":"2022-08-25","objectID":"/dp/:1:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#斐波那契数列"},{"categories":["algorithm"],"content":" 2 凑零钱问题 给你k种面值的硬币，面值分别为c1, c2 ... ck，每种硬币的数量无限，再给一个总金额amount，问你最少需要几枚硬币凑出这个金额， 如果不可能凑出，算法返回 -1 。算法的函数签名如下： // coins 中是可选硬币面值，amount 是目标金额 int coinChange(int[] coins, int amount); 比如说k = 3，面值分别为 1，2，5，总金额amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。 ","date":"2022-08-25","objectID":"/dp/:2:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#凑零钱问题"},{"categories":["algorithm"],"content":" 2.1 暴力递归首先，这个问题是动态规划问题，因为它具有「最优子结构」。要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？ 比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。 得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。 那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程。 先确定 状态，也就是原问题和子问题中变化的变量。由于硬币数量无限，所以唯一的状态就是目标金额 amount。 然后确定 dp 函数的定义：函数 dp(n)表示，当前的目标金额是 n，至少需要 dp(n) 个硬币凑出该金额。 然后确定选择并择优，也就是对于每个状态，可以做出什么选择改变当前状态。 具体到这个问题，无论当的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少： def coinChange(coins: List[int], amount: int): def dp(n): # base case if n == 0: return 0 if n \u003c 0: return -1 # 求最小值，所以初始化为正无穷 res = float('INF') for coin in coins: subproblem = dp(n - coin) # 子问题无解，跳过 if subproblem == -1: continue res = min(res, 1 + subproblem) return res if res != float('INF') else -1 return dp(amount) 至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程： 至此，这个问题其实就解决了，只不过需要消除一下重叠子问题,比如amount = 11, coins = {1,2,5}时画出递归树看看： 时间复杂度分析：子问题总数 x 解决每个子问题的时间。 子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。 ","date":"2022-08-25","objectID":"/dp/:2:1","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#暴力递归"},{"categories":["algorithm"],"content":" 2.2 带备忘录的递归只需要稍加修改，就可以通过备忘录消除子问题： def coinChange(coins: List[int], amount: int): # 备忘录 memo = dict() def dp(n): # 查备忘录，避免重复计算 if n in memo: return memo[n] if n == 0: return 0 if n \u003c 0: return -1 res = float('INF') for coin in coins: subproblem = dp(n - coin) if subproblem == -1: continue res = min(res, 1 + subproblem) # 记入备忘录 memo[n] = res if res != float('INF') else -1 return memo[n] return dp(amount) 显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。 处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。 ","date":"2022-08-25","objectID":"/dp/:2:2","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#带备忘录的递归"},{"categories":["algorithm"],"content":" 2.3 dp 数组当然，我们也可以自底向上使用 dp table 来消除重叠子问题，dp 数组的定义和刚才 dp 函数类似，定义也是一样的： dp[i] = x 表示，当目标金额为 i 时，至少需要 x 枚硬币。 int coinChange(vector\u003cint\u003e\u0026 coins, int amount) { // 数组大小为 amount + 1，初始值也为 amount + 1 vector\u003cint\u003e dp(amount + 1, amount + 1); // base case dp[0] = 0; for (int i = 0; i \u003c dp.size(); i++) { // 内层 for 在求所有子问题 + 1 的最小值 for (int coin : coins) { // 子问题无解，跳过 if (i - coin \u003c 0) continue; dp[i] = min(dp[i], 1 + dp[i - coin]); } } return (dp[amount] == amount + 1) ? -1 : dp[amount]; } PS：为啥dp数组初始化为amount + 1呢，因为凑成amount金额的硬币数最多只可能等于amount（全用 1 元面值的硬币），所以初始化为amount + 1就相当于初始化为正无穷，便于后续取最小值。 ","date":"2022-08-25","objectID":"/dp/:2:3","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#dp-数组"},{"categories":["algorithm"],"content":" 2.4 JS 版【LeetCode 322】 零钱兑换（中等） 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：coins = [2], amount = 3 输出：-1 示例 3： 输入：coins = [1], amount = 0 输出：0 /** * @param {number[]} coins * @param {number} amount * @return {number} */ var coinChange = function(coins, amount) { if (amount === 0) return 0; let dp = []; for (let i = 0; i \u003c= amount; i++) { dp[i] = amount + 1; } dp[0] = 0; for (let i = 0; i \u003c= amount; i++) { for (let j = 0; j \u003c coins.length; j++) { if (i \u003e= coins[j]) { 1\u003e=1 2\u003e=1 // dp[1]=1 dp[2]=1 dp[5]=1 dp[i] = Math.min(dp[i - coins[j]] + 1, dp[i]) } } } return dp[amount] === amount + 1 ? -1 : dp[amount]; }; ","date":"2022-08-25","objectID":"/dp/:2:4","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#js-版"},{"categories":["algorithm"],"content":" 3 最长递增子序列【LeetCode 300】 最长递增子序列（中等） 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 没有说是否连续。拆分为 到 第 n 个 元素的最长递增序列，分别求解，第 n+1 个即为 前 n 个中小于 num[n] 中的最大的 +1 。 /** * @param {number[]} nums * @return {number} */ var lengthOfLIS = function(nums) { let dp = []; for(let i=0;i\u003cnums.length;i++){ dp[i]=1; } let res = 1; for(let i=0;i\u003cnums.length;i++){ for(let j=i;j\u003e=0;j--){ if(nums[i] \u003e nums[j]){ dp[i] = Math.max(dp[j]+1,dp[i]); } } res = Math.max(dp[i],res); } return res; }; ","date":"2022-08-25","objectID":"/dp/:3:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#最长递增子序列"},{"categories":["algorithm"],"content":" 4 最长公共子序列【LeetCode 1143】 最长公共子序列（中等） 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 输入：text1 = \"abcde\", text2 = \"ace\" 输出：3 解释：最长公共子序列是 \"ace\" ，它的长度为 3 。 示例 2： 输入：text1 = \"abc\", text2 = \"abc\" 输出：3 解释：最长公共子序列是 \"abc\" ，它的长度为 3 。 示例 3： 输入：text1 = \"abc\", text2 = \"def\" 输出：0 解释：两个字符串没有公共子序列，返回 0 。 /** * @param {string} text1 * @param {string} text2 * @return {number} */ var longestCommonSubsequence = function(text1, text2) { const m = text1.length, n = text2.length; const dp = new Array(m + 1).fill(0).map(() =\u003e new Array(n + 1).fill(0)); for (let i = 1; i \u003c= m; i++) { const c1 = text1[i - 1]; for (let j = 1; j \u003c= n; j++) { const c2 = text2[j - 1]; if (c1 === c2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; }; ","date":"2022-08-25","objectID":"/dp/:4:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#最长公共子序列"},{"categories":["algorithm"],"content":" 5 编辑距离【LeetCode 直通车】：72 编辑距离（困难） 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数。你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -\u003e rorse (将 'h' 替换为 'r') rorse -\u003e rose (删除 'r') rose -\u003e ros (删除 'e') 示例 2： 输入：word1 = \"intention\", word2 = \"execution\" 输出：5 解释： intention -\u003e inention (删除 't') inention -\u003e enention (将 'i' 替换为 'e') enention -\u003e exention (将 'n' 替换为 'x') exention -\u003e exection (将 'n' 替换为 'c') exection -\u003e execution (插入 'u') 首先分析可以进行的操作，A 插入、删除、替换、B 插入、删除、替换，共六种。 再细看，A 插入等价于 B 删除，A 删除等价于 B 插入，A 替换等价于 B 替换，实际共三种。 A 插入一个：如果我们知道 horse 到 ro 的编辑距离为 a，那么显然 horse 到 ros 的编辑距离不会超过 a + 1。这是因为我们可以在 a 次操作后将 horse 和 ro 变为相同的字符串，只需要额外的 1 次操作，在单词 A 的末尾添加字符 s，就能在 a + 1 次操作后将 horse 和 ro 变为相同的字符串； B 中插入一个：如果我们知道 hors 到 ros 的编辑距离为 b，那么显然 horse 到 ros 的编辑距离不会超过 b + 1，原因同上； 修改 A 一个：如果我们知道 hors 到 ro 的编辑距离为 c，那么显然 horse 到 ros 的编辑距离不会超过 c + 1，原因同上。 那么从 horse 变成 ros 的编辑距离应该为 min(a + 1, b + 1, c + 1)。将原来问题的答案转换为许多子问题的答案。 用 D[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。 可得其状态转移方程为 D[i][j]=1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]) 如果最后一个字母相等，那么 D[i][j] = D[i-1][j-1]。此时状态方程为: 1+min(D[i][j−1],D[i−1][j],D[i−1][j−1]−1) 对于边界情况：对于边界情况，一个空串和一个非空串的编辑距离为 D[i][0] = i 和 D[0][j] = j，D[i][0] 相当于对 word1 执行 i 次删除操作，D[0][j] 相当于对 word1执行 j 次插入操作。 /** * @param {string} word1 * @param {string} word2 * @return {number} */ var minDistance = function(word1, word2) { let len1 = word1.length, len2 = word2.length; let dp = []; // dp 数组初始化 for (let i = 0; i \u003c= len1; i++) { dp[i] = []; for (let j = 0; j \u003c= len2; j++) { dp[i][j] = 0; if (i === 0) { dp[i][j] = j; } if (j === 0) { dp[i][j] = i; } } } // dp 数组填充值 for (let i = 1; i \u003c= len1; i++) { for (let j = 1; j \u003c= len2; j++) { if (word1[i - 1] === word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]); } } } // return 值 return dp[len1][len2]; }; ","date":"2022-08-25","objectID":"/dp/:5:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#编辑距离"},{"categories":["algorithm"],"content":" 6 最长回文子序列【LeetCode 516】最长回文子序列（中等） 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 输入：s = \"bbbab\" 输出：4 解释：一个可能的最长回文子序列为 \"bbbb\" 。 示例 2： 输入：s = \"cbbd\" 输出：2 解释：一个可能的最长回文子序列为 \"bb\" 。 对于一个子序列而言，如果它是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。 用 dp[i][j] 表示字符串 s 的下标范围 [i, j] 内的最长回文子序列的长度。假设字符串 s 的长度为 n，则只有当 0 ≤ i ≤ j \u003c n 时，才会有 dp[i][j]\u003e 0，否则 dp[i][j]=0。 由于任何长度为 1 的子序列都是回文子序列，因此动态规划的边界情况是，对任意 0 ≤ i \u003c n，都有 dp[i][i] = 1。 当 i \u003c j 时，计算 dp[i][j] 需要分别考虑 s[i] 和 s[j] 相等和不相等的情况： 如果 s[i]=s[j]，则首先得到 s 的下标范围 [i+1,j−1] 内的最长回文子序列，然后在该子序列的首尾分别添加 s[i] 和 s[j]，即可得到 s 的下标范围 [i, j]内的最长回文子序列，因此 dp[i][j] = dp[i+1][j−1] + 2； 如果 s[i] != s[i] ，则 s[i] 和 s[j] 不可能同时作为同一个回文子序列的首尾，因此 dp[i][j] = max(dp[i+1][j], dp[i][j−1])。 由于状态转移方程都是从长度较短的子序列向长度较长的子序列转移，因此需要注意动态规划的循环顺序。 最终得到 dp[0][n−1] 即为字符串 s 的最长回文子序列的长度。 /** * @param {string} * @return {number} */ var longestPalindromeSubseq = function(s) { let dp = []; for (let i = 0; i \u003c s.length; i++) { dp[i] = []; for (let j = 0; j \u003c s.length; j++) { dp[i][j] = 0; } dp[i][i] = 1; } for (let i = s.length - 1; i \u003e= 0; i--) { for (let j = i + 1; j \u003c s.length; j++) { if (s[i] === s[j]) { dp[i][j] = dp[i + 1][j - 1] + 2; } else { dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); } } } return dp[0][s.length - 1]; }; ","date":"2022-08-25","objectID":"/dp/:6:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#最长回文子序列"},{"categories":["algorithm"],"content":" 7 最大子序和【LeetCode 53】最大子序和（简单） 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [5,4,-1,7,8] 输出：23 重点：dp[i] 表示到 i 为止，前面的最大的子数组的和。有： dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]); /** * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { let maxSum = -Infinity; let dp = [], n = nums.length; for (let i = -1; i \u003c n; i++) { dp[i] = 0; } for (let i = 0; i \u003c n; i++) { dp[i] = Math.max(nums[i], dp[i - 1] + nums[i]); maxSum = Math.max(maxSum, dp[i]); } return maxSum; }; var maxSubArray = function(nums) { let n = nums.length; let dp = []; for(let i=0; i\u003cn; i++){ dp[i] = 0; } dp[0] = nums[0]; let res = dp[0]; for(let i=1;i\u003cn;i++){ dp[i] = Math.max(dp[i-1]+nums[i], nums[i]); res = Math.max(res,dp[i]); } return res; }; ","date":"2022-08-25","objectID":"/dp/:7:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#最大子序和"},{"categories":["algorithm"],"content":" 8 买卖股票的最佳时机【LeetCode 直通车】：121 买卖股票的最佳时机（简单） 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 ","date":"2022-08-25","objectID":"/dp/:8:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#买卖股票的最佳时机"},{"categories":["algorithm"],"content":" 8.1 暴力循环双层遍历可解，但是会超时，时间复杂度为 O(n^2); ","date":"2022-08-25","objectID":"/dp/:8:1","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#暴力循环"},{"categories":["algorithm"],"content":" 8.2 单层遍历 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { let min = Infinity, max = 0; for (let price of prices) { max = Math.max(max, price - min); min = Math.min(price, min); } return max; }; ","date":"2022-08-25","objectID":"/dp/:8:2","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#单层遍历"},{"categories":["algorithm"],"content":" 8.3 DP /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { let n = prices.length,dp=[]; if (n == 0) return 0; // 边界条件 let minprice = prices[0]; for(let i=-1;i\u003cn;i++){ dp[i]=0; } for (let i = 1; i \u003c n; i++){ minprice = Math.min(minprice, prices[i]); dp[i] = Math.max(dp[i - 1], prices[i] - minprice); } return dp[n - 1]; }; ","date":"2022-08-25","objectID":"/dp/:8:3","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#dp"},{"categories":["algorithm"],"content":" 9 买卖股票的最佳时机 II【LeetCode 直通车】：122 买卖股票的最佳时机 II（中等） 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 定义状态dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。 考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程： dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]} 再来考虑 dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。可以列出如下的转移方程： dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]} 对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0][0]=0，dp[0][1]=−prices[0]。 因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为 dp[n−1][0]。 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { const n = prices.length; const dp = new Array(n).fill(0).map(v =\u003e new Array(2).fill(0)); console.log(dp); dp[0][0] = 0, dp[0][1] = -prices[0]; for (let i = 1; i \u003c n; ++i) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } console.log(dp); return dp[n - 1][0]; }; ","date":"2022-08-25","objectID":"/dp/:9:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#买卖股票的最佳时机-ii"},{"categories":["algorithm"],"content":" 10 买卖股票的最佳时机 III• 👉 【LeetCode 直通车】：123 买卖股票的最佳时机 III（困难） ","date":"2022-08-25","objectID":"/dp/:10:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#买卖股票的最佳时机-iii"},{"categories":["algorithm"],"content":" 11 买卖股票的最佳时机IV• 👉 【LeetCode 直通车】：188 买卖股票的最佳时机IV（困难） ","date":"2022-08-25","objectID":"/dp/:11:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#买卖股票的最佳时机iv"},{"categories":["algorithm"],"content":" 12 买卖股票的最佳时机含冷冻期• 👉 【LeetCode 直通车】：309 买卖股票的最佳时机含冷冻期（中等） ","date":"2022-08-25","objectID":"/dp/:12:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#买卖股票的最佳时机含冷冻期"},{"categories":["algorithm"],"content":" 13 买卖股票的最佳时机含手续费• 👉 【LeetCode 直通车】：714 买卖股票的最佳时机含手续费（中等） ","date":"2022-08-25","objectID":"/dp/:13:0","series":[],"tags":["DP"],"title":"动态规划","uri":"/dp/#买卖股票的最佳时机含手续费"},{"categories":["algorithm"],"content":"贪心算法（greedy algorithm），又称贪婪算法，是寻找最优解问题的常用方法。 ","date":"2022-08-25","objectID":"/greedy/:0:0","series":[],"tags":["Greey"],"title":"贪心算法","uri":"/greedy/#"},{"categories":["algorithm"],"content":" 1 简介贪心算法（greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。 贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。 贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。在不同情况，选择最优的解，可能会导致辛普森悖论（Simpson’s Paradox），不一定出现最优的解。 ","date":"2022-08-25","objectID":"/greedy/:1:0","series":[],"tags":["Greey"],"title":"贪心算法","uri":"/greedy/#简介"},{"categories":["algorithm"],"content":" 2 基本步骤：步骤1：从某个初始解出发； 步骤2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模； 步骤3：将所有解综合起来。 ","date":"2022-08-25","objectID":"/greedy/:2:0","series":[],"tags":["Greey"],"title":"贪心算法","uri":"/greedy/#基本步骤"},{"categories":["algorithm"],"content":" 3 跳跃游戏【LeetCode 直通车】：55 跳跃游戏（中等） 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 有关动态规划的问题，大多是让你求最值的，比如最长子序列，最小编辑距离，最长公共子串等等等。这就是规律，因为动态规划本身就是运筹学里的一种求最值的算法。 那么贪心算法作为特殊的动态规划也是一样，一般也是求最值。这道题表面上不是求最值，但是可以改一改： 请问通过题目中的跳跃规则，最多能跳多远？如果能够越过最后一格，返回 true，否则返回 false。 所以说，这道题肯定可以用动态规划求解的。但是由于它比较简单，直接上贪心： var canJump = function(nums) { let faster = 0; for (let i = 0; i \u003c nums.length - 1; i++) { faster = Math.max(faster, i + nums[i]); if (faster \u003c= i) return false; } return faster \u003e= nums.length - 1; }; ","date":"2022-08-25","objectID":"/greedy/:3:0","series":[],"tags":["Greey"],"title":"贪心算法","uri":"/greedy/#跳跃游戏"},{"categories":["algorithm"],"content":" 4 跳跃游戏 II【LeetCode 直通车】：45 跳跃游戏 II（中等） 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组 的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 从后往前，以始为终，找能到 n 的最远的 n-1，再找能到 n-1 的 最远 n-2。 var jump = function(nums) { let count = 0; if(nums.length == 1) { return count; } // 最後一個位置。 for(let i = nums.length-1; i \u003e 0; i--) { // 取出当前位置的值 // 从前往后循环都一样，因为你必须循环一遍，才能找到最大的那一个元素。 // 最后前面的一个元素，肯定可以达到，至少为 1 步 // 从前向后，记录肯定是最远的。 for(let j = 0; j \u003c i; j++) { // 哪一个值并不重要，重要的是距离 let len = i - j; let maxLen = nums[j]; // 可以达到 if(maxLen \u003e= len \u0026\u0026 len \u003e 1) { i -= (len-1); break; } } // 次数递增 count++; } return count; }; 另一种思路 例：[2,3,1,1,4] 输出：2 var jump = function(nums) { let n = nums.length; let end = 0, farthest = 0; let jumps = 0; for (let i = 0; i \u003c n - 1; i++) { // 0 1 2 3 4 farthest = Math.max(nums[i] + i, farthest); // 2 4 3 4 8 if (end == i) { // 0 jumps++; // 1 2 end = farthest; // 2 4 } } return jumps; }; ","date":"2022-08-25","objectID":"/greedy/:4:0","series":[],"tags":["Greey"],"title":"贪心算法","uri":"/greedy/#跳跃游戏-ii"},{"categories":["Data"],"content":"本文中介绍些数组相关的高频算法题，LeetCode 实战分享。 ","date":"2022-08-24","objectID":"/array/:0:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#"},{"categories":["Data"],"content":" 1 俄罗斯套娃信封问题 【LeetCode 直通车】：354 俄罗斯套娃信封问题（困难） 给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候， 这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 说明: 不允许旋转信封。 示例 1： 输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3 解释：最多信封的个数为 3, 组合为: [2,3] =\u003e [5,4] =\u003e [6,7]。 示例 2： 输入：envelopes = [[1,1],[1,1],[1,1]] 输出：1 ","date":"2022-08-24","objectID":"/array/:1:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#俄罗斯套娃信封问题"},{"categories":["Data"],"content":" 1.1 排序+最长上升子序列 var maxEnvelopes = function(envelopes) { if (envelopes.length === 1) return 1; envelopes.sort((a, b) =\u003e { if (a[0] !== b[0]) return a[0] - b[0]; else return b[1] - a[1]; }); let LISArr = []; for (let [key, value] of envelopes) { LISArr.push(value); } console.log( LISArr); return LIS(LISArr); }; // w: 2 -\u003e 3 -\u003e 4 -\u003e 4 -\u003e 5 -\u003e 6 // h: 4 -\u003e 2 -\u003e 2 -\u003e 3 -\u003e 6 -\u003e 5 // [最长上升子序列](https://www.geekxh.com/1.2.动态规划系列/203.html#_01、题目分析) function LIS(arr) { let dp = []; // dp[i]表示以arr[i]结尾的最长递增子序列 let maxAns = 0; for (let i = 0; i \u003c arr.length; i++) { dp[i] = 1; } for (let i = 1; i \u003c arr.length; i++) { for (let j = i; j \u003e= 0; j--) { if (arr[i] \u003e arr[j]) { dp[i] = Math.max(dp[i], dp[j] + 1) } maxAns = Math.max(maxAns, dp[i]); } } return maxAns; } ","date":"2022-08-24","objectID":"/array/:1:1","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#排序最长上升子序列"},{"categories":["Data"],"content":" 2 最长连续递增序列【LeetCode 直通车】：674 最长连续递增序列（简单） 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l \u003c r）确定，如果对于每个 l \u003c= i \u003c r，都有 nums[i] \u003c nums[i + 1] ， 那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 ","date":"2022-08-24","objectID":"/array/:2:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#最长连续递增序列"},{"categories":["Data"],"content":" 2.1 快慢指针 /** * @param {number[]} nums * @return {number} */ var findLengthOfLCIS = function(nums) { if (nums.length === 0) return 0; const n = nums.length; let left = 0, right = 1; let globalMaxLen = 1, maxLen = 1; while (right \u003c n) { if (nums[right] \u003e nums[left]) maxLen++; else { maxLen = 1; } left++; right++; globalMaxLen = Math.max(globalMaxLen, maxLen); } return globalMaxLen; }; ","date":"2022-08-24","objectID":"/array/:2:1","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#快慢指针"},{"categories":["Data"],"content":" 2.2 动态规划解法与最长子序列相比多了个连续，也正是多了这个连续得：不用再遍历之前的取最大值了，只比较前面一个就行，也就变成了纸哟一轮循环即可解决问题。 var findLengthOfLCISCIS = function (nums) { if (nums.length === 0) return; console.log(nums.length) let result=1; let dp = []; for (let i = 0; i \u003c nums.length; i++) { dp[i] = 1; } for (let i = 0; i \u003c nums.length - 1; i++) { if (nums[i + 1] \u003e nums[i]) { // 连续记录 dp[i + 1] = dp[i] + 1; } if (dp[i + 1] \u003e result) result = dp[i + 1]; } return result; } ","date":"2022-08-24","objectID":"/array/:2:2","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#动态规划解法"},{"categories":["Data"],"content":" 3 最长连续序列【LeetCode 直通车】：128 最长连续序列（困难） 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 查找是否连续，即查找 +1 或 -1 是否存在，查找用哈希 双层循环的查找可以解决问题，但是时间复杂度 n^2 优化：尽可能从最小值开始找，怎么尽可能，存在 -1 的数，肯定不是最小。 ","date":"2022-08-24","objectID":"/array/:3:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#最长连续序列"},{"categories":["Data"],"content":" 3.1 哈希表 /** * @param {number[]} nums * @return {number} */ var longestConsecutive = function(nums) { if (nums.length === 0) return 0; const set = new Set(nums); const n = nums.length; let globalLongest = 1; for (let i = 0; i \u003c n; i++) { if (!set.has(nums[i] - 1)) { let longest = 1; let currentNum = nums[i]; while (set.has(currentNum + 1)) { currentNum += 1; longest++; } globalLongest = Math.max(globalLongest, longest); } } return globalLongest; }; ","date":"2022-08-24","objectID":"/array/:3:1","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#哈希表"},{"categories":["Data"],"content":" 4 盛最多水的容器【LeetCode 11】： 盛最多水的容器（中等） 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 示例 1 如上图 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1 双循环肯定能借=解，但是肯定不是最优方案 双头往中间走，双层循环变单层循环，走的条件即 放弃短的那个，短的装水少 /** * @param {number[]} height * @return {number} */ var maxArea = function(height) { let n = height.length; let left = 0, right = n - 1; let maxOpacity = 0; while (left \u003c right) { let res = Math.min(height[left], height[right]) * (right - left); maxOpacity = Math.max(maxOpacity, res); if (height[left] \u003c height[right]) left++ else right--; } return maxOpacity; }; ","date":"2022-08-24","objectID":"/array/:4:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#盛最多水的容器"},{"categories":["Data"],"content":" 5 寻找两个正序数组的中位数LeetCode 4 寻找两个正序数组的中位数（困难） 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 ","date":"2022-08-24","objectID":"/array/:5:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#寻找两个正序数组的中位数"},{"categories":["Data"],"content":" 5.1 正常合并找中位数 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */ var findMedianSortedArrays = function(nums1, nums2) { let m = nums1.length, n = nums2.length; let i = 0, j = 0; let newArr = []; while (i \u003c m \u0026\u0026 j \u003c n) { if (nums1[i] \u003c nums2[j]) { newArr.push(nums1[i++]); } else { newArr.push(nums2[j++]); } } newArr = newArr.concat(i \u003c m ? nums1.slice(i) : nums2.slice(j)); const len = newArr.length; console.log(newArr) if (len % 2 === 0) { return (newArr[len / 2] + newArr[len / 2 - 1]) / 2; } else { return newArr[Math.floor(len / 2)]; } }; ","date":"2022-08-24","objectID":"/array/:5:1","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#正常合并找中位数"},{"categories":["Data"],"content":" 5.2 二分中位数，即可理解为第 len/2=k 大或小的数，以第 len/2=k 小为例。 分别对两个有序数组取 k/2 的值比较大小，小的即淘汰。之后再找第 k-x 小的元素。 依次循环，直至找到第 1 小即可。注意其中的特例情况。 var findMedianSortedArrays = function(nums1, nums2) { const len1 = nums1.length; const len2 = nums2.length; const mid = (len1 + len2 + 1) \u003e\u003e 1; const left = getK(nums1, nums2, 0, 0, mid); // 判断总长度奇偶 if ((len1 + len2) % 2) { return left; //奇数 } else { const right = getK(nums1, nums2, 0, 0, mid + 1); return (left + right) / 2 } }; // 取第k小的数 function getK(nums1, nums2, start1, start2, k) { const len1 = nums1.length; const len2 = nums2.length; /* 特例 */ // nums1 数组的元素排除完 if (len1 === start1) return nums2[start2 + k - 1]; if (len2 === start2) return nums1[start1 + k - 1]; // 排除到只剩两个元素取最小 即剩余元素的最小值 if (k === 1) return Math.min(nums1[start1], nums2[start2]); /* 通常情况 */ // 取k的一半 同时注意可能会超出数组长度 最多取数组最后一个元素 const i = start1 + Math.min(len1, k \u003e\u003e 1) - 1; const j = start2 + Math.min(len2, k \u003e\u003e 1) - 1; // j 前面的所有元素被排除了 同时缩减k的值 if (nums1[i] \u003e nums2[j]) { return getK(nums1, nums2, start1, j + 1, k - (j - start2 + 1)); } else { return getK(nums1, nums2, i + 1, start2, k - (i - start1 + 1)); } } ","date":"2022-08-24","objectID":"/array/:5:2","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#二分"},{"categories":["Data"],"content":" 6 删除有序数组中的重复项【LeetCode 26】删除有序数组中的重复项（简单 给你一个升序排列的数组 nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 ","date":"2022-08-24","objectID":"/array/:6:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#删除有序数组中的重复项"},{"categories":["Data"],"content":" 6.1 快慢指针 /** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) { if (nums.length \u003c= 1) return nums.length; let lo = 0, hi = 0; while (hi \u003c nums.length) { while (nums[lo] === nums[hi] \u0026\u0026 hi \u003c nums.length) hi++; if (nums[lo] !== nums[hi] \u0026\u0026 hi \u003c nums.length) { lo++; nums[lo] = nums[hi]; } hi++; } return lo + 1; }; ","date":"2022-08-24","objectID":"/array/:6:1","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#快慢指针-1"},{"categories":["Data"],"content":" 7 和为K的子数组【LeetCode 560】：和为K的子数组（中等） 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的`连续子数组`的个数 。 示例 1： 输入：nums = [1,1,1], k = 2 输出：2 示例 2： 输入：nums = [1,2,3], k = 3 输出：2 ","date":"2022-08-24","objectID":"/array/:7:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#和为k的子数组"},{"categories":["Data"],"content":" 7.1 暴力循环针对所有情况的子数组首尾位置，计算其中元素之和，看是否等于 k，但是这里面存在着大量的重复计算，时间复杂度是O(n^2) ","date":"2022-08-24","objectID":"/array/:7:1","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#暴力循环"},{"categories":["Data"],"content":" 7.2 单循环其实也可以事先计算出到每个位置的元素和sum，那子数组 nums[i:j]=(nums[0]+nums[1]+ ··· +nums[j]) - (nums[0]+nums[1]+ ··· +nums[i-1])=sum[j]-sum[i-1]，这样我们用二重循环的方式就可以解决，时间复杂度降到了 O(n) 。 ","date":"2022-08-24","objectID":"/array/:7:2","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#单循环"},{"categories":["Data"],"content":" 7.3 哈希表我们可以用哈希表，我们可以在元素累加的过程中得到 sum[j]=nums[0]+nums[1]+ ··· +nums[j]，并放入哈希表中。如果我们可以在哈希表中发现之前存在着 sum[i] 使得 sum[j]-sum[i]=k，那么也就说明了有一个子序列之和为 k。时间复杂度终于被降到了 。 当存在多个sum[i]使得sum[j]-sum[i]=k成立时，可以加上对应的数量就行了。注意，需要初始化 hash[0]=1，这样 sum==k 时才能被计数。 /** * @param {number[]} nums * @param {number} k * @return {number} */ var subarraySum = function(nums, k) { const mp = new Map(); mp.set(0, 1); let count = 0, pre = 0; for (const x of nums) { pre += x; if (mp.has(pre - k)) { // 为什么这样就 count+ count += mp.get(pre - k); } if (mp.has(pre)) { mp.set(pre, mp.get(pre) + 1); } else { mp.set(pre, 1); map(1:1,0:1) } } return count; }; ","date":"2022-08-24","objectID":"/array/:7:3","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#哈希表-1"},{"categories":["Data"],"content":" 8 nSum问题【哈希表】","date":"2022-08-24","objectID":"/array/:8:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#nsum问题哈希表"},{"categories":["Data"],"content":" 8.1 两数之和【LeetCode 直通车】：1 两数之和（简单） 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] var twoSum = function(nums, target) { let map2 = new Map(); for (let i = 0; i \u003c nums.length; i++) { map2.set(nums[i], i); } for (let i = 0; i \u003c nums.length; i++) { if (map2.has(target - nums[i]) \u0026\u0026 map2.get(target - nums[i]) !== i) return [i, map2.get(target - nums[i])] } }; ","date":"2022-08-24","objectID":"/array/:8:1","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#两数之和"},{"categories":["Data"],"content":" 8.2 两数之和 II【LeetCode 直通车】：167 两数之和 II - 输入有序数组（简单） ","date":"2022-08-24","objectID":"/array/:8:2","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#两数之和-ii"},{"categories":["Data"],"content":" 8.3 三数之和【LeetCode 直通车】：15 三数之和（中等） 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] ","date":"2022-08-24","objectID":"/array/:8:3","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#三数之和"},{"categories":["Data"],"content":" 8.4 四数之和【LeetCode 直通车】：18 四数之和（中等） 题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ， 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 「注意：」答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 四个数求和，需要四个变量来控制着进行遍历。 钉死两个，for 循环 i 和 j ，在 while (left \u003c right) ，四个变量。 可以事前排个序来减少一些，不必要的循环。 var fourSum = function(nums, target) { const quadruplets = []; if (nums.length \u003c 4) { return quadruplets; } nums.sort((x, y) =\u003e x - y); const length = nums.length; for (let i = 0; i \u003c length - 3; i++) { if (i \u003e 0 \u0026\u0026 nums[i] === nums[i - 1]) { continue; } if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] \u003e target) { break; } if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] \u003c target) { continue; } for (let j = i + 1; j \u003c length - 2; j++) { if (j \u003e i + 1 \u0026\u0026 nums[j] === nums[j - 1]) { continue; } if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] \u003e target) { break; } if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] \u003c target) { continue; } let left = j + 1, right = length - 1; while (left \u003c right) { const sum = nums[i] + nums[j] + nums[left] + nums[right]; if (sum === target) { quadruplets.push([nums[i], nums[j], nums[left], nums[right]]); while (left \u003c right \u0026\u0026 nums[left] === nums[left + 1]) { left++; } left++; while (left \u003c right \u0026\u0026 nums[right] === nums[right - 1]) { right--; } right--; } else if (sum \u003c target) { left++; } else { right--; } } } } return quadruplets; }; ","date":"2022-08-24","objectID":"/array/:8:4","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#四数之和"},{"categories":["Data"],"content":" 9 接雨水【LeetCode 直通车】：42 接雨水（困难 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 heigh: 0 1 0 2 1 0 1 3 2 1 2 1 l_max: [0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3] r_max: [3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1] max : 001 012 100 100 var trap = function(height) { let l_max = [], r_max = []; let len = height.length; let maxCapacity = 0; for (let i = 0; i \u003c len; i++) { l_max[i] = height[i]; r_max[i] = height[i]; } for (let i = 1; i \u003c len; i++) { l_max[i] = Math.max(l_max[i - 1], height[i]); } for (let j = len - 2; j \u003e= 0; j--) { r_max[j] = Math.max(r_max[j + 1], height[j]); } for (let i = 0; i \u003c len; i++) { maxCapacity += Math.min(l_max[i], r_max[i]) - height[i]; } return maxCapacity; }; ","date":"2022-08-24","objectID":"/array/:9:0","series":[],"tags":["array"],"title":"数组的那个组","uri":"/array/#接雨水"},{"categories":["Data"],"content":"本文中介绍些字符串相关的高频算法题，LeetCode 实战分享。 ","date":"2022-08-21","objectID":"/string/:0:0","series":[],"tags":["String"],"title":"字符串那个串","uri":"/string/#"},{"categories":["Data"],"content":" 1 最长回文子串【双指针】【LeetCode 直通车】：5 最长回文子串（中等） 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 示例 2： 输入：s = \"cbbd\" 输出：\"bb\" 思路：首先是奇数和偶数的不同，即 aba 和 abba 两种情况，是两种思路和算法。核心是判断左右两侧是否相等。 利用 for 循环开始遍历，从 i 开始依次向左、右，左-k 与 右+k 依次比较，相等就是回文看回文的长度。 情况二就是从 i 和 i+1 开始依次比较，获取长度。 var longestPalindrome = function(s) { if (s.length === 1) return s; let maxRes = 0, maxStr = ''; for (let i = 0; i \u003c s.length; i++) { let str1 = palindrome(s, i, i); let str2 = palindrome(s, i, i + 1); if (str1.length \u003e maxRes) { maxStr = str1; maxRes = str1.length; } if (str2.length \u003e maxRes) { maxStr = str2; maxRes = str2.length; } } return maxStr; }; function palindrome(s, l, r) { while (l \u003e= 0 \u0026\u0026 r \u003c s.length \u0026\u0026 s[l] === s[r]) { l--; r++; } return s.slice(l + 1, r); } ","date":"2022-08-21","objectID":"/string/:1:0","series":[],"tags":["String"],"title":"字符串那个串","uri":"/string/#最长回文子串双指针"},{"categories":["Data"],"content":" 2 最长公共前缀【双指针】【LeetCode 直通车】：14 最长公共前缀（简单） 编写一个函数来查找字符串数组中的最长公共前缀 如果不存在公共前缀，返回空字符串 \"\"。 示例 1： 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" 示例 2： 输入：strs = [\"dog\",\"racecar\",\"car\"] 输出：\"\" 解释：输入不存在公共前缀。 ","date":"2022-08-21","objectID":"/string/:2:0","series":[],"tags":["String"],"title":"字符串那个串","uri":"/string/#最长公共前缀双指针"},{"categories":["Data"],"content":" 2.1 遍历两两依次比拿第一个依次与后面的去取去比较，取公共的最小值即可。 var longestCommonPrefix = function(strs) { if (strs.length === 0) return \"\"; let first = strs[0]; if (first === \"\") return \"\"; let minLen = Number.MAX_SAFE_INTEGER; for (let i = 1; i \u003c strs.length; i++) { const len = twoStrLongestCommonPrefix(first, strs[i]); minLen = Math.min(len, minLen); } return first.slice(0, minLen); }; function twoStrLongestCommonPrefix (s, t) { let i = 0, j = 0; let cnt = 0; while (i \u003c s.length \u0026\u0026 j \u003c t.length) { console.log(s[i], t[j], cnt) if (s[i] === t[j]) { cnt++; } else { return cnt; } i++; j++; } return cnt; } ","date":"2022-08-21","objectID":"/string/:2:1","series":[],"tags":["String"],"title":"字符串那个串","uri":"/string/#遍历两两依次比"},{"categories":["Data"],"content":" 2.2 判断是否为子串思路二： 判断字符串 2 是否在字符串 1 里是否为子串。 是：在判断 2 是否在 3.4.5…n 里 否：字符串 2 长度减 1，再判。判断方法 string.indexof 返回的下标是否为 0 func longestCommonPrefix(strs []string) string { if len(strs) \u003c 1 { return \"\" } prefix := strs[0] for _,k := range strs { for strings.Index(k,prefix) != 0 { if len(prefix) == 0 { return \"\" } prefix = prefix[:len(prefix) - 1] } } return prefix } ","date":"2022-08-21","objectID":"/string/:2:2","series":[],"tags":["String"],"title":"字符串那个串","uri":"/string/#判断是否为子串"},{"categories":["Data"],"content":" 3 无重复字符的最长子串【双指针】【LeetCode 直通车】：3 无重复字符的最长子串（中等） 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 右移一直 减减 到重复元素处。取左边的值减减，减至左边元素与右边相等处即，不再减 var lengthOfLongestSubstring = function(s) { let window = {}; let left = 0, right = 0; let maxLen = 0, maxStr = ''; while (right \u003c s.length) { let c = s[right]; //a right++; //1 if (window[c]) window[c]++; else window[c] = 1 while (window[c] \u003e 1) { let d = s[left]; left++; window[d]--; } if (maxLen \u003c right - left) { maxLen = right - left; } } return maxLen; }; ","date":"2022-08-21","objectID":"/string/:3:0","series":[],"tags":["String"],"title":"字符串那个串","uri":"/string/#无重复字符的最长子串双指针"},{"categories":["Data"],"content":" 4 最小覆盖子串 【LeetCode 直通车】：76 最小覆盖子串（困难） 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 输入：s = \"ADOBECODEBANC\", t = \"ABC\" 输出：\"BANC\" 示例 2： 输入：s = \"a\", t = \"a\" 输出：\"a\" 示例 3: 输入: s = \"a\", t = \"aa\" 输出: \"\" 解释: t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 var minWindow = function(s, t) { let need = {}, window = {}; for (let c of t) { if (!need[c]) need[c] = 1; else need[c]++; //need:包含 t 数组的元素的 } let left = 0, right = 0; let valid = 0, len = Object.keys(need).length; let minLen = s.length + 1, minStr = ''; while (right \u003c s.length) { // \"ADOBECODEBANC\", t = \"ABC\" const d = s[right]; l r right++; if (!window[d]) window[d] = 1; else window[d]++; if (need[d] \u0026\u0026 need[d] === window[d]) { valid++; } console.log('left - right', left, right); while (valid === len) { if (right - left \u003c minLen) { minLen = right - left; // 5 minStr = s.slice(left, right); //ADOBEC CODEBA } let c = s[left]; left++; window[c]--; if (need[c] \u0026\u0026 window[c] \u003c need[c]) { valid--; } } } return minStr; }; ","date":"2022-08-21","objectID":"/string/:4:0","series":[],"tags":["String"],"title":"字符串那个串","uri":"/string/#最小覆盖子串"},{"categories":["Data"],"content":"本文中介绍些链表相关的高频算法题，LeetCode 实战分享。 ","date":"2022-08-18","objectID":"/linkedlist/:0:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#"},{"categories":["Data"],"content":" 1 回文链表👉 【LeetCode 直通车】：234 回文链表（简单） 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 ","date":"2022-08-18","objectID":"/linkedlist/:1:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#回文链表"},{"categories":["Data"],"content":" 1.1 递归遍历利用链表的后续遍历，使用函数调用栈作为后序遍历栈，来判断是否回文。 递归到最后之后，最后一个跟头节点比较，然后递归回退一个，头节点往下走，依次实现，第几个和倒数第几个实现一个比较。 let left ; var isPalindrome = function(head) { left = head; return traverse(head); }; function traverse(right) { if (right == null) return true; let res = traverse(right.next); res = res \u0026\u0026 (right.val === left.val); left = left.next; return res; } ","date":"2022-08-18","objectID":"/linkedlist/:1:1","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#递归遍历"},{"categories":["Data"],"content":" 1.2 快慢指针通过 快、慢指针找链表中点，然后反转链表，比较两个链表两侧是否相等，来判断是否是回文链表 var isPalindrome = function(head) { // 反转 slower 链表 let right = reverse(findCenter(head)); let left = head; // 开始比较 while (right != null) { if (left.val !== right.val) { return false; } left = left.next; right = right.next; } return true; } function findCenter(head) { let slower = head, faster = head; while (faster \u0026\u0026 faster.next != null) { slower = slower.next; faster = faster.next.next; } // 如果 faster 不等于 null，说明是奇数个，slower 再移动一格 if (faster != null) { slower = slower.next; } return slower; } function reverse(head) { let prev = null, cur = head, nxt = head; while (cur != null) { nxt = cur.next; cur.next = prev; prev = cur; cur = nxt; } return prev; } ","date":"2022-08-18","objectID":"/linkedlist/:1:2","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#快慢指针"},{"categories":["Data"],"content":" 2 反转链表 【LeetCode 直通车】：206 反转链表（简单） 给你单链表的头节点 Head，请你反转链表，并返回反转后的链表。 ","date":"2022-08-18","objectID":"/linkedlist/:2:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#反转链表"},{"categories":["Data"],"content":" 2.1 递归反转利用递归走到最后一个之后，让最后一个成为第一个。断开最后一个和倒数第二个的连接，return 最后一个，此时得到的应该是就是最后一个变成头的链表。 利用递归的特性，再依次使得倒数第二个变成头，倒数第三个变成头，倒数…… 即可。 var reverseList = function(head) { if (head == null || head.next == null) return head; let last = reverseList(head.next); head.next.next = head; head.next = null; return last; }; ","date":"2022-08-18","objectID":"/linkedlist/:2:1","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#递归反转"},{"categories":["Data"],"content":" 2.2 三个指针当前节点，前一个节点，后一个节点，三个指针完成链表的反转，并依次移动。 var reverseList = function(head) { let prev = null, cur = head, nxt = head; while (cur != null) { nxt = cur.next; // 往后走 cur.next = prev; // 更新连接 prev = cur; // 往前走 cur = nxt; // 往前走 } return prev; }; ","date":"2022-08-18","objectID":"/linkedlist/:2:2","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#三个指针"},{"categories":["Data"],"content":" 3 合并K个升序链表【LeetCode 直通车】：23 合并K个升序链表（困难） 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6 ] 将它们合并到一个有序链表中得到。 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6 ","date":"2022-08-18","objectID":"/linkedlist/:3:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#合并k个升序链表"},{"categories":["Data"],"content":" 3.1 归并排序思想 var mergeKLists = function(lists) { if (lists.length === 0) return null; return mergeArr(lists); }; function mergeArr(lists) { if (lists.length \u003c= 1) return lists[0]; let index = Math.floor(lists.length / 2); const left = mergeArr(lists.slice(0, index)) const right = mergeArr(lists.slice(index)); return merge(left, right); } function merge(l1, l2) { if (l1 == null \u0026\u0026 l2 == null) return null; if (l1 != null \u0026\u0026 l2 == null) return l1; if (l1 == null \u0026\u0026 l2 != null) return l2; let newHead = null, head = null; while (l1 != null \u0026\u0026 l2 != null) { if (l1.val \u003c l2.val) { if (!head) { newHead = l1; head = l1; } else { newHead.next = l1; newHead = newHead.next; } l1 = l1.next; } else { if (!head) { newHead = l2; head = l2; } else { newHead.next = l2; newHead = newHead.next; } l2 = l2.next; } } newHead.next = l1 ? l1 : l2; return head; } ","date":"2022-08-18","objectID":"/linkedlist/:3:1","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#归并排序思想"},{"categories":["Data"],"content":" 4 K 个一组翻转链表【LeetCode 直通车】：25 K 个一组翻转链表（困难） 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 示例 2： 输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5] ","date":"2022-08-18","objectID":"/linkedlist/:4:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#k-个一组翻转链表"},{"categories":["Data"],"content":" 4.1 分批来 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @param {number} k * @return {ListNode} */ var reverseKGroup = function(head, k) { let a = head, b = head; for (let i = 0; i \u003c k; i++) { if (b == null) return head; b = b.next; } const newHead = reverse(a, b); a.next = reverseKGroup(b, k); return newHead; }; function reverse(a, b) { let prev = null, cur = a, nxt = a; while (cur != b) { nxt = cur.next; cur.next = prev; prev = cur; cur = nxt; } return prev; } ","date":"2022-08-18","objectID":"/linkedlist/:4:1","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#分批来"},{"categories":["Data"],"content":" 5 环形链表【LeetCode 直通车】：141 环形链表（简单） ","date":"2022-08-18","objectID":"/linkedlist/:5:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#环形链表"},{"categories":["Data"],"content":" 5.1 快慢指针 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {boolean} */ var hasCycle = function(head) { if (head == null || head.next == null) return false; let slower = head, faster = head; while (faster != null \u0026\u0026 faster.next != null) { slower = slower.next; faster = faster.next.next; if (slower === faster) return true; } return false; }; ","date":"2022-08-18","objectID":"/linkedlist/:5:1","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#快慢指针-1"},{"categories":["Data"],"content":" 6 排序链表 【LeetCode 直通车】：148 排序链表（中等） 给你链表的头节点，请你将其按照 升序 排序后，返回。 var sortList = function(head) { if (head == null) return null; let newHead = head; return mergeSort(head); }; function mergeSort(head) { if (head.next != null) { let slower = getCenter(head); let nxt = slower.next; slower.next = null; console.log(head, slower, nxt); const left = mergeSort(head); const right = mergeSort(nxt); head = merge(left, right); } return head; } function merge(left, right) { let newHead = null, head = null; while (left != null \u0026\u0026 right != null) { if (left.val \u003c right.val) { if (!head) { newHead = left; head = left; } else { newHead.next = left; newHead = newHead.next; } left = left.next; } else { if (!head) { newHead = right; head = right; } else { newHead.next = right; newHead = newHead.next; } right = right.next; } } newHead.next = left ? left : right; return head; } function getCenter(head) { let slower = head, faster = head.next; while (faster != null \u0026\u0026 faster.next != null) { slower = slower.next; faster = faster.next.next; } return slower; } ","date":"2022-08-18","objectID":"/linkedlist/:6:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#排序链表"},{"categories":["Data"],"content":" 7 相交链表【LeetCode 直通车】：160 相交链表（简单） 两个链表以步伐一，开始跑，跑到底就再从另个一头节点开始跑。 如果两个链表相交，那么终会在某节点相等。 var getIntersectionNode = function(headA, headB) { let lastHeadA = null; let lastHeadB = null; let originHeadA = headA; let originHeadB = headB; if (!headA || !headB) { return null; } while (true) { if (headB == headA) { return headB; } if (headA \u0026\u0026 headA.next == null) { lastHeadA = headA; headA = originHeadB; } else { headA = headA.next; } if (headB \u0026\u0026 headB.next == null) { lastHeadB = headB headB = originHeadA; } else { headB = headB.next; } if (lastHeadA \u0026\u0026 lastHeadB \u0026\u0026 lastHeadA != lastHeadB) { return null; } } return null; }; ","date":"2022-08-18","objectID":"/linkedlist/:7:0","series":[],"tags":["Linked List"],"title":"链表那个链","uri":"/linkedlist/#相交链表"},{"categories":["tool"],"content":"介绍 git 相关使用方法，一些命令的介绍。也是 git pro 读书笔记。 ","date":"2022-08-14","objectID":"/git/:0:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#"},{"categories":["tool"],"content":" 1 什么是gitgit 是分布式的版本管理系统。本地仓库有代码，远端仓库也有代码。没有网络可以先在本地开发，之后有了网络再进行提交。 ","date":"2022-08-14","objectID":"/git/:1:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#什么是git"},{"categories":["tool"],"content":" 2 版本控制客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。本质是对文件变更过程的管理工作，需要的时候可以进入指定的版本。 ","date":"2022-08-14","objectID":"/git/:2:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#版本控制"},{"categories":["tool"],"content":" 3 快照流当你提交更新或者保存项目状态的时候，git基本上会对当时所有的文件创建一个快照并保存这个快照的索引。 如果文件没有修改，Git将不再重复存储该文件，而是保留一个链接指向之前存储的文件的索引。 ","date":"2022-08-14","objectID":"/git/:3:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#快照流"},{"categories":["tool"],"content":" 4 本地执行git 既有远程仓库又有本地仓库，在本地几乎可以完成绝大多数的 git 的常用操作，置于推送到远程服务，啥时候有网啥时候弄就行。 ","date":"2022-08-14","objectID":"/git/:4:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#本地执行"},{"categories":["tool"],"content":" 5 git 保存完整性如果在传输的过程中，出现了文件丢失的情况，git会及时的发现，因为git底层有一个计算校验和的机制，叫做 SHA-1 散列 (hash，哈希)。是基于git中文件的内容或目录结构计算出来的一个由40个十六进制数组成的字符串。 git 一般只添加数据，很难让 git 执行任何不可逆操作，或者让他以任何方式清除数据。未提交更新时可能丢失或弄乱修改的内容，但是一旦提交快照到git中，就很难在丢失数据，要养成定期推送的好习惯。 ","date":"2022-08-14","objectID":"/git/:5:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#git-保存完整性"},{"categories":["tool"],"content":" 6 三种状态已提交(committed):以保存在本地数据库中 已暂存(staged): 对修改过的文件做了标记使之包含在在此提交的快照中 已修改(modified): 只是修改了文件，并没有保存到数据库中 ","date":"2022-08-14","objectID":"/git/:6:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#三种状态"},{"categories":["tool"],"content":" 7 获取git仓库的两种方式 在已存在目录中初始化仓库: 如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。执行： git init。 这是会在该文件下创建一个 .git 文件，但此时还没有被跟踪，下一步，开始追踪： git add *.c git add LICENSE //添加为跟踪文件 git commit -m 'initial project version' git clone \u003curl\u003e 会克隆下git仓库服务器上的几乎所有数据，不是用什么克隆什么。 Git clone \u003c url\u003e newName 支持，克隆本地后在本地用新名字。而且不但支持http协议，还支持SSH等多种协议。 git status 每一个文件都只有两种状态，已跟踪 或 未跟踪。已跟踪的文件就是已经纳入版本控制的文件。初次克隆仓库的时候，所有的文件都是已跟踪文件，未修改的状态。 git status 可以查看文件的状态。 ","date":"2022-08-14","objectID":"/git/:7:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#获取git仓库的两种方式"},{"categories":["tool"],"content":" 8 跟踪新文件假设现在刚创建了一个文件，该文件就是未跟踪状态。git status之后，会有 Untrack files：XXX 的提示，而且 git 仓库并不会直接把它纳入跟踪范围，需要手动添加，命令： git add XXX。 暂存已修改的文件：当修改了一个已跟踪的文件之后，再 git status 会，显示 Changes not staged for commit。即修改没放到暂存区。放到暂存区的命令还是git add \u003c某文件\u003e。 git add. 可以将所有修改的文件均放到暂存区。放入暂存区再修改再git status会发现，该文件既在暂存区又在非暂存区。因为上次的git add仅仅包含上次的修改。 状态简览：使用命令git status -s 或者 git status —short会得到一种格式更为简洁的输出。 $ git status -s M README // 修改过的是 M 标记 MM Makefile // A lib/git.rb // 新添加到暂存区的是 A 标记 M lib/simplegit.rb ?? LICENSE.txt // ？？表示新添加的未跟踪的文件 ","date":"2022-08-14","objectID":"/git/:8:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#跟踪新文件"},{"categories":["tool"],"content":" 9 忽略文件像一些日志文件、编译产生的临时文件等无用文件无需跟踪，我们就可以创建一个 .gitignore 文件来忽略这些文件。该文件格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以/开头防止递归。匹配模式可以以 / 结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符； [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（）表示匹配任意中间目录，比如 a//z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 我们再看一个 .gitignore 文件的例子： # 忽略所有的 .a 文件 *.a # 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件 !lib.a # 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO /TODO # 忽略任何目录下名为 build 的文件夹 build/ # 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt doc/*.txt # 忽略 doc/ 目录及其所有子目录下的 .pdf 文件 doc/**/*.pdf ","date":"2022-08-14","objectID":"/git/:9:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#忽略文件"},{"categories":["tool"],"content":" 10 查看已暂存和未暂存的修改Git diff：此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。只显示尚未暂存的改动。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异： ","date":"2022-08-14","objectID":"/git/:10:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#查看已暂存和未暂存的修改"},{"categories":["tool"],"content":" 11 提交更新git commit：可以看到，默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。 还可以直接：git commit -m “说明信息” 直接提交 给 git commit 加上 -a 之后，可以跳过 git add. 步骤直接提交。 git commit -am 'commit 信息' ","date":"2022-08-14","objectID":"/git/:11:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#提交更新"},{"categories":["tool"],"content":" 12 移除文件rm XXX 这样删除文件，文件会出现在未暂存清单中，再 git rm XXX。就不再纳入版本管理了。 如果要删除之前放在暂存区的文件要加 -f 。 如果忘记了添加忽略文件或从暂存区移除但保存在本地磁盘上且不再版本控制，可以用 git rm --cached xxx ，xxx 可以是文件名字还可以是目录 ","date":"2022-08-14","objectID":"/git/:12:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#移除文件"},{"categories":["tool"],"content":" 13 移动文件git mv aaa bbb：相当于下面三条指令，效果一样，git mv 更加方便。 mv aaa bbb git rm aaa git add bbb ","date":"2022-08-14","objectID":"/git/:13:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#移动文件"},{"categories":["tool"],"content":" 14 查看提交历史git log：不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 在包含 git log 输出的信息之外的同时，还会输出 git diff 输出的 diff 内容。 还可以限制显示的日志条目数量，-2 选项来只显示最近的两次提交。-\u003cn\u003en次 --stat 选项：可以看到每次提交的简略统计信息 git log --pretty=format ：可以定制记录的显示格式。更多看这里 $ git log —since=2.weeks 最近两周 $ git log -S function_name 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用 来看一个实际的例子，如果要在 Git 源码库中查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件，可以使用下面的命令： $ git log --pretty=\"%h - %s\" --author='Junio C Hamano' --since=\"2008-10-01\" \\ --before=\"2008-11-01\" --no-merges -- t/ ","date":"2022-08-14","objectID":"/git/:14:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#查看提交历史"},{"categories":["tool"],"content":" 15 提交信息合并git commit —amend 会将暂存区的文件提交，如果上次提交后没有更改，只是修改提交信息。 如果有文件没有提交： $ git commit -m 'initial commit' $ git add forgotten_file $ git commit —amend 最终只会有一个提交结果，旧的提交结果就像从来没有存在过一样，保证了仓库提交历史的干净。 ","date":"2022-08-14","objectID":"/git/:15:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#提交信息合并"},{"categories":["tool"],"content":" 16 撤销操作git reset：将当前的分支的 HEAD 指向给定的版本，并根据参数 [–soft, –mixed, –hard] 决定对于工作区和暂存区内文件的修改。默认参数为 mixed。 git reset --soft commit_id：-soft 参数仅仅会将 HEAD 回退到某个版本，不修改暂存区和工作区的内容。 git reset --mixed commit_id：–mixed 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。 git reset --hard commit_id：–hard 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交。 将 HEAD 回退到指定版本号，比如有提交 1，2，3。可以直接回退到1，此时2，3，就没有了。下次提交需要加 -f 强制提交。 git revert：假设有提交 1，2，3。想要撤销2保留3，即可使用此命令，revert 后会生成提交4 ，4里面撤销了2，保留了3。 ","date":"2022-08-14","objectID":"/git/:16:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#撤销操作"},{"categories":["tool"],"content":" 17 取消暂存的文件git reset HEAD xxx 将文件从已暂存状态变为 修改未暂存状态。 ","date":"2022-08-14","objectID":"/git/:17:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#取消暂存的文件"},{"categories":["tool"],"content":" 18 取消对文件的修改：git checkout -- xxx 但是 git checkout -- \u003cfile\u003e 是一个危险的命令。 你对那个文件在本地的任何修改都会消失，Git 会用最近提交的版本覆盖掉它。 ","date":"2022-08-14","objectID":"/git/:18:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#取消对文件的修改"},{"categories":["tool"],"content":" 19 查看远程仓库git remote： 会列出制定的每一个远程服务器的简写。如果已克隆会有默认名字：orgin。 git remote -v：会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。有多个的话，会一一列出。 ","date":"2022-08-14","objectID":"/git/:19:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#查看远程仓库"},{"categories":["tool"],"content":" 20 查看某个远程仓库git remote show origin ：同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull， 就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。 显示的信息更加的详细。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 git pull 时哪些本地分支可以与它跟踪的远程分支自动合并。 ","date":"2022-08-14","objectID":"/git/:20:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#查看某个远程仓库"},{"categories":["tool"],"content":" 21 添加远程仓库git remote add \u003cshortname\u003e \u003curl\u003e 添加一个新的远程 Git 仓库，shortnamae即重命名 ","date":"2022-08-14","objectID":"/git/:21:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#添加远程仓库"},{"categories":["tool"],"content":" 22 推送到远程仓库git push \u003c远程主机名\u003e \u003c本地分支名\u003e:\u003c远程分支名\u003e：git push 的命令格式。 git push orgin master \u003c==\u003e git push origin master:master：将 master 分支，推送到 origin 服务器上。 git push --force origin master：如果本地版本与远程版本有差异，但又要强制推送可以使用 –force 参数： git push origin --delete master：删除主机的分支可以使用 –delete 参数，以下命令表示删除 origin 主机的 master 分支： ","date":"2022-08-14","objectID":"/git/:22:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#推送到远程仓库"},{"categories":["tool"],"content":" 23 远程仓库的移除和重命名git remote rename pb paul 将pb更名为paul。 git remote remove Paul：移除远程仓库 ","date":"2022-08-14","objectID":"/git/:23:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#远程仓库的移除和重命名"},{"categories":["tool"],"content":" 24 远程仓库拉取数据git fetch \u003cremote\u003e：访问远程仓库，并拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 Git clone ：如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 git pull \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e：git clone + git merge ，git pull origin master:brantest，将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。 git pull origin master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 ","date":"2022-08-14","objectID":"/git/:24:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#远程仓库拉取数据"},{"categories":["tool"],"content":" 25 创建标签(轻量标签，附注标签)轻量标签：像一个不会改变的分支，只是某个特定提交的引用。轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： git tag v1.4-lw 创建名为 v1.4-lw 的轻量标签。查看该标签只会有提交信息 附注标签：是存储在 git 数据库中的一个完整对象，它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 git tag -a v1.4 -m “My version 1.4” 创建附注标签，-m 后为描述信息，没有的话会启动文本编辑器让你添加，类似于 git commit -m “描述信息” 。 ","date":"2022-08-14","objectID":"/git/:25:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#创建标签轻量标签附注标签"},{"categories":["tool"],"content":" 26 列出标签git tag(可带上-l或-list)：将标签列出来 git tag -l “*v1*” (匹配标签名的通配模式下，必须加-l)：会筛选v1开头的 ","date":"2022-08-14","objectID":"/git/:26:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#列出标签"},{"categories":["tool"],"content":" 27 后期打标签git tag -a v1.2 9fceb02：要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和） ","date":"2022-08-14","objectID":"/git/:27:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#后期打标签"},{"categories":["tool"],"content":" 28 共享标签推送标签并不会区分轻量标签和附注标签 git push origin \u003ctagname\u003e：向远程推送标签，这样别人拉代码时也会将标签拉下来 git push origin —tags：这将会把所有不在远程仓库服务器上的标签全部传送到那里。 ","date":"2022-08-14","objectID":"/git/:28:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#共享标签"},{"categories":["tool"],"content":" 29 删除标签$ git tag -d \u003ctagname\u003e：删除一个轻量标签，仅本地 $ git push \u003cremote\u003e :refs/tags/\u003ctagname\u003e 来更新你的远程仓库同步删除 $ git push \u003cremote\u003e :refs/tags/\u003ctagname\u003e ：变体1 将冒号前面的空值推送到远程标签名，从而高效地删除它。 $ git push origin --delete \u003ctagname\u003e：变体2 更直观的删除远程标签的方式 ","date":"2022-08-14","objectID":"/git/:29:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#删除标签"},{"categories":["tool"],"content":" 30 检出标签git checkout 2.0.0：查看某个标签所指向的文件版本，但是这会使你的仓库处于分离头指针（detached HEAD）的状态——–这个状态有些不好的副作用。在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支： git checkout -b version2 v2.0.0 switched to a new branch 'version2' 如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。 ","date":"2022-08-14","objectID":"/git/:30:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#检出标签"},{"categories":["tool"],"content":" 31 Git 命令别名git config --global alias.co checkout git co == git checkout git config --global alias.br branch git br == git branch git config --global alias.unstage 'reset HEAD —' git onstage fileA == git reset HEAD -- fileA ","date":"2022-08-14","objectID":"/git/:31:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#git-命令别名"},{"categories":["tool"],"content":" 32 分支简介在进行提交操作的时候，git 会保存一个提交对象，该提交对象会包含一个指向暂存内容快照的指针。以及作者的姓名邮箱、提交时输入的信息、父对象的指针等内容。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。 一个目录里面有三个文件，修改暂存提交之后。git 会计算该目录的校验和，并保存为树对象，该树对象有指向文件快照blob对象的指针。 还有一个提交对象，包含指向树对象的指针。提交对象有指向树的指针，树对象有指向文件快照blob对象的指针。如果修改后再次提交，新的提交对象还会有一个指向上一次提交的对象的指针，即父指针。Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 ","date":"2022-08-14","objectID":"/git/:32:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#分支简介"},{"categories":["tool"],"content":" 33 分支创建git branch aab :会创建一个可以移动的新指针 Git 中的 HEAD 是一个指针，指向当前所在的本地分支 master (一般本地分支默认名称为 master)。 刚创建的 aab 指针和 master 指向的是同一个提交对象。HEAD 指向 master。 git log --oneline —decorate ：查看当前各个分支当前所指的对象。 git checkout aab ： 切换分支，此时 HEAD 指向 aab。 在 aab 上做了部分修改并提交后，aab分支会向前移动指向新的提交对象，但是 master 还是原来的不变。此时再切回 master，整个工作目录会变成 master 对应的状态。在这里修改并提交，master 会向前移动，master 的向前一步走和 aab 的向前一步走就分叉了。 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），更加的简单高效。 ","date":"2022-08-14","objectID":"/git/:33:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#分支创建"},{"categories":["tool"],"content":" 34 分支的新建与合并git branch xxx : 创建新分支 git checkout xxx : 切换到分支 xxx 上 git checkout -b xxx : 创建新分支并切换到新分支上。 git merge xxx : 当前分支合并 xxx 分支。如果要合并的分支并不是当前分支的直接祖先，此时 git 就会合并两个分支的末端和两个分支的公共祖先做一个三方合并。 git branch -d xxx : 删除分支 xxx ","date":"2022-08-14","objectID":"/git/:34:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#分支的新建与合并"},{"categories":["tool"],"content":" 35 分支管理git branch : 不加参数的时候会得到分支列表，列表中带有 * 的分支就是当前检出的分支，即 HEAD 指针指向的分支 git branch -v : 查看每个分支的最后一次提交 git branch —merged : 查看已经合并到当前分支的分支 git branch —no-merged : 查看所有未合并工作的分支 git branch --no-merged master : 尚未合并到master分支上的分支有哪些 ","date":"2022-08-14","objectID":"/git/:35:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#分支管理"},{"categories":["tool"],"content":" 36 分支重命名本地: git branch -m oldName newName 远程: 重命名远程分支对应的本地分支，git branch -m oldName newName 删除远程分支，git push --delete origin oldName 上传新命名的本地分支，git push origin newName 把修改后的本地分支与远程分支关联，git branch --set-upstream-to origin/newName ","date":"2022-08-14","objectID":"/git/:36:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#分支重命名"},{"categories":["tool"],"content":" 37 远程分支远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信，Git 就会为你移动它们以精确反映远程仓库的状态。该分支在远程仓库中的位置就是你最后一次连接到它们的位置。如果在你工作的时候，别人向远程仓库推送了新的提交，那么远程仓库的 master 会更新。但是我们的 origin/master 分支并不会移动，还是我们之前与远程仓库通信时的位置。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据，创建一个指向的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin的 master 分支在指向同一个地方的本地 master 分支。 git fecth orgin: 用来拉取远程仓库的最新的修改数据，移动 origin/master 到更新后位置 git merge orgin: 将拉取的数据与当前的本地数据合并 git push origin serverfix: 将本地的 serverfix 分支来更新远程仓库上的 serverfix git push origin serverfix:serverfix: 效果一样 git push origin serverfix:a: 将本地分支 serverfix 推送到远程 a 分支上 ","date":"2022-08-14","objectID":"/git/:37:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#远程分支"},{"categories":["tool"],"content":" 38 跟踪分支克隆仓库时，自动创建的 master 分支就是默认跟踪的 origin/master 分支，执行 git pull 后自动的去 origin/master 上拉取数据并合并到master分支上。跟踪分支后就知道了去那个服务器拉取数据，合并到那个分支上面。当然，可以手动设置让分支跟踪那个分支。 git checkout --track origin/serverfix: 设置分支 serverfix 跟踪远程仓库中的分支 serverfix git checkout serverfix: 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支 git checkout -b sf origin/serverfix : 将本地分支与远程分支设置为不同的名字,sf 会从 origin/serverfix 上面拉取数据 git branch -vv: 可以查看设置的所有跟踪分支，还有分支所跟踪的远程分支与本地分支是否领先还是落后 git push origin --delete serverfix: 删除远程分支 ","date":"2022-08-14","objectID":"/git/:38:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#跟踪分支"},{"categories":["tool"],"content":" 39 变基变基：详见 ","date":"2022-08-14","objectID":"/git/:39:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#变基"},{"categories":["tool"],"content":" 40 cherry-pickgit cherry-pick \u003ccommitHash\u003e：上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。 ","date":"2022-08-14","objectID":"/git/:40:0","series":[],"tags":["git"],"title":"git pro 读书笔记","uri":"/git/#cherry-pick"},{"categories":["hugo"],"content":"使用 mac+hugo+github 搭建个人博客。 ","date":"2022-08-05","objectID":"/mac-hugo/:0:0","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#"},{"categories":["hugo"],"content":" 1 准备工作","date":"2022-08-05","objectID":"/mac-hugo/:1:0","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#准备工作"},{"categories":["hugo"],"content":" 1.1 brew安装/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ","date":"2022-08-05","objectID":"/mac-hugo/:1:1","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#brew安装"},{"categories":["hugo"],"content":" 1.2 githubgithub上创建一个仓库，仓库的名称格式一定是：username.github.io ","date":"2022-08-05","objectID":"/mac-hugo/:1:2","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#github"},{"categories":["hugo"],"content":" 2 安装步骤","date":"2022-08-05","objectID":"/mac-hugo/:2:0","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#安装步骤"},{"categories":["hugo"],"content":" 2.1 hugo 安装打开终端 输入命令,直接按住那个 hugo,在已安装 homebrew 的环境下。 brew 命令可直接检测是否已成功安装 brew,当出现 Example usage: 等信息的情况下，即已成功安装 brew。 brew install hugo hugo version // 可查看是否已经安装好。 ","date":"2022-08-05","objectID":"/mac-hugo/:2:1","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#hugo-安装"},{"categories":["hugo"],"content":" 2.2 创建总目录hugo new site myblog 最后一个单词 myblog 为在当前目录下生成文件夹名，也是你的网站的大本营，后续大部分的操作都在这个文件夹下进行。 ","date":"2022-08-05","objectID":"/mac-hugo/:2:2","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#创建总目录"},{"categories":["hugo"],"content":" 2.3 配置主题可在 hugo 官网 主题进行下载主题,下载的主题要放在博客根目录的 themes 目录下。 以 hugo-theme-even 为 🌰 git init git clone https://github.com/olOwOlo/hugo-theme-even themes/even 按着主题中的 .toml 文件修改 myBlog 中的 .toml 文件，因为需要给主题设置些参数。 一定好好研究主题中的 .toml 文件或直接 copy 过来。 ","date":"2022-08-05","objectID":"/mac-hugo/:2:3","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#配置主题"},{"categories":["hugo"],"content":" 2.4 本地运行hugo server -t theme-name --buildDrafts 其中 theme-name 为你下载的主题名称,如果没问题就会提示成功的信息，给出本地调试链接:localhost:1313,此时终端会持续运行，不会结束。 浏览器打开 localhost:1313 ，如果能正常显示，说明在本地服务器运行已经没问题。 ","date":"2022-08-05","objectID":"/mac-hugo/:2:4","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#本地运行"},{"categories":["hugo"],"content":" 2.5 显示文章如要在网页上显示文章，在根目录下的 content–\u003epost 中生成一个 .md 文件，此时将写好的文章 copy 至此文件中，可再按照上一条命令进行测试。 输入命令创建即可 hugo new post/readme.md ","date":"2022-08-05","objectID":"/mac-hugo/:2:5","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#显示文章"},{"categories":["hugo"],"content":" 2.6 在github上测试首先在github上创建好仓库，注意事项见“准备工作”。 在根目录下输入命令 hugo --theme=theme-name --baseUrl=\"https://username.github.io/\" --buildDrafts， 此命令会在根目录下生成一 public 的文件夹，里面存放的就是生成的网页的代码。 接下来需要将这个目录上传至建好的仓库中，在 public 目录下依次使用命令: git init git add . git commit -m \"init\" git remote add origin https://github.com/username/username.github.io.git git push -u origin master 最后一个命令输完后可能需要 github 密码, 需要到 GitHub 中申请个人令牌 经过以上操作后，在网页中访问 https://username.github.io/即可看到搭建后的网页 ","date":"2022-08-05","objectID":"/mac-hugo/:2:6","series":["hugos"],"tags":["hugo"],"title":"Mac+hugo+github 搭建个人博客","uri":"/mac-hugo/#在github上测试"},{"categories":null,"content":"这是一篇名为README的文章。 但是我我还没想好 readme 里写点什么。 ","date":"2022-08-05","objectID":"/readme/:0:0","series":null,"tags":["readme"],"title":"README","uri":"/readme/#"}]